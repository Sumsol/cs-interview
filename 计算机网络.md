# 计算机网络

<!--Note-->
## 资料

- 《计算机网络 自顶向下方法》
- 《计算机网络》
- 《TCP/IP 详解 卷 1：协议》
- 《UNIX 网络编程 卷 1：套接字联网 API》
- 《Linux 多线程服务端编程》
- 《图解 HTTP》
<!--/Note-->

## 基础

- [计算机网络](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络)

### 体系结构

#### OSI七层协议

##### 表示层 ：数据压缩、加密以及数据描述。

##### 会话层 ：建立及管理会话。

#### TCP/IP四层协议

#### 五层协议

##### 应用层

###### 数据传输服务对象

####### 特定应用程序

###### 协议

####### DNS，HTTP，FTP，SMTP，POP3，DHCP，SCOKS

###### 数据单元

####### 报文

##### 运输层

###### 数据传输服务对象

####### 进程

###### 数据单元

####### 报文段，用户数据报

###### 协议 

####### TCP，UDP

##### 网络层

###### 数据传输服务对象

####### 主机

###### 数据单元

####### 分组

###### 协议

####### ARP，ICMP，RIP，OSPF, BGP

##### 数据链路层

###### 数据传输服务对象

####### 同一链路的主机

###### 数据单元

####### 帧

###### 协议

####### PPP

######## 一对一，如用户与ISP

######## 点对点信道

####### CSMA/CD

######## 载波监听多点接入/碰撞检测

######## 广播信道

###### 三个基本问题

####### 封装成帧

######## 分组加首部和尾部

####### 透明传输

######## 转义字符转义首部、尾部和自身

####### 差错检测

######## 循环冗余检验（CRC）

##### 物理层

###### 透明传送传输比特流，屏蔽传输介质和物理设备差异

###### 数据单元

####### 比特

###### 信道复用技术

####### 时分复用

####### 统计时分复用

####### 频分复用

####### 波分复用

####### 码分复用

#### 图

#####  

### 以太网

#### 局域网是广播信道，分星型，环形和总线型

#### 以太网是星型结构局域网

### 网络硬件设备

- 集线器、交换机、路由器的作用，以及所属的网络层。

#### 集线器

##### 物理层设备

##### 功能

###### 放大比特能量，扩大传输距离

###### 会发生碰撞

#### 交换机

##### 链路层设备

##### 功能

###### 自学习能力，即插即用

###### 交换表：MAC地址 - 接口

#### 路由器

##### 分组发送

###### 路由表：目的网络 - 下一跳路由

#######  

###### 根据网络地址，选择直接交付、下一跳路由器和默认路由器

##### 路由选择协议

随通信量和拓扑结构自适应调整

###### 自治系统AS

####### 使用相同路由选择协议

###### 内部网关协议

####### RIP

######## 距离向量算法

#########  

####### OSPF

######## 最短路径算法

###### 外部网关协议

####### BGP（Border Gateway Protocol）

### IP 数据报

#### 格式

#####  

#### 片偏移

#####  

#### 首部检验和

#####  

#### 最大传输单元MTU

##### 1500

### ARP 协议

#### 每个主机都有ARP高速缓存: IP地址 - MAC地址

#####  

#### ARP请求分组，ARP响应分组

#####  

### ICMP 协议

#### 询问报文 

##### Ping

###### 发送Echo请求报文，返回Echo回答报文

###### 数据包 往返时间 以及 丢包率。

#### 差错报告报文

##### Traceroute

###### 发送无法交付的UDP，TTL从1开始，中间路由返回时间超过，目的主机返回终点不可达。

####  

### UDP 与 TCP

#### 传输控制协议TCP

##### 面向连接、可靠交付、面向字节流、点对点

##### 首部格式

- 源端口和目的端口——各占2字节。端口是应用层与传输层的服务接口。
- 序号——占4字节。TCP连接传输的数据流中的每一个字节都会被编上一个序号。而这里的序号字段指的是发送的数据段中第一个字节的序号。
- 确认号——占4字节。是期望收到对方下一次发来的序号字段的值。
- 数据偏移——占4bit。指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- 确认ACK——当ACK=1时确认号（第三行的） 有效，当ACK=0时确认号无效。
- 同步SYN——当SYN=1时，表明这是一个连接请求或者连接接受报文。
- 终止FIN——当FYN=1时，表明此报文段的发送方的数据已发送完毕，并且要求释放连接。
- 窗口字段——占2字节。包含滑动窗口和拥塞窗口，后面详解。
- 校验和——占2字节。包括首部校验和数据校验两部分。在计算校验和的时候要在TCP报文段前面加上12字节的伪首部。

######  

##### 文件传输、发送和接收邮件、远程登录等场景。

#### 用户数据报协议UDP

##### 无连接、尽最大可能交付、面向报文、广播或多播

##### 首部格式

端口：是应用层和传输层的服务接口
UDP长度：首部 + 数据总长度
UDP校验和：伪首部、首部、数据 三部分的校验和
伪首部：它并不是在UDP数据报中存在的有效数据，也不会被发送，它的存在仅是为了计算校验和，所以叫做伪首部。它是提取了源IP地址、目的IP地址等字段构造的数据。

######  

##### QQ 语音、 QQ 视频 、直播等等

####  

### TCP 连接

- 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。

#### TCP三次握手

##### 图

######  

##### 三次握手原因

###### 防止服务器打开已经失效连接

###### 确保对方发送接收正常

####### 第一次握手，服务器只确定客户端发送正常

####### 第二次握手，客户端确定服务端发送、接收正常，建立连接

####### 第三次握手，服务端确定客户端发送、接收正常，建立连接

#### TCP四次挥手

##### 图

######  

##### 四次挥手原因

###### 第二次握手，防止客户端FIN报文超时重发

###### 第三次握手，表示服务端数据发送完毕，可以断开连接了

##### TIME_WAIT

###### 确保最后一个确认报文到达，服务端不超时重发

###### 2MSL内所有报文消失，防止影响下次连接

MSL为报文最长生存时间。

####### ACK报文最晚1MSL到达，并等待重发的FIN报文1MSL后消失，故TIME_WAIT 为 2MSL

###### Socket可选项中将SO_REUSEADDR设为1，可禁止

```
optlen = sizeof(option);
option = TRUE;
setsockopt(serv_sock, SOL_SOCKET, SO_REUSEADDR, (void *)&option, optlen);
```

### TCP 可靠传输

- 设计可靠 UDP 协议

#### 确认号 + 序号

##### TCP给发送的每一个包进行编号，接收方对接收的数据进行按序确认，把有序数据传送给应用层。

#### 校验和

##### 发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。

#### 超时重传

##### 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

#### 流量控制

##### 滑动窗口

######  

##### 流量控制

###### 控制发送方速率，使接收方来得及接收

###### 发送窗口 <= 接收窗口

#### 拥塞控制

### TCP 拥塞控制

#### 慢开始和拥塞避免

cwnd随传输轮次的变化，每过一个往返时间RTT就算一轮。

##### 慢开始

###### 从cwnd = 1 SMSS 开始，cwnd指数增长

##### 拥塞避免

###### 当cwnd >= ssthresh，cwnd线性增长

##### 出现超时，令ssthresh = cwnd / 2, 重新执行慢开始

#### 快重传和快恢复 

##### 快重传

###### 丢失M3报文段，收到3个M2重复确认，立即快重传M3

#######  

##### 快恢复

###### 快重传时，令 ssthresh = cwnd / 2 ，cwnd = ssthresh

####  

#####  

### DNS

#### DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。

#### 大多用UDP传输，长度超过 512 字节时使用 TCP，端口号53

#### DNS查询

#####  

#### 域名服务器和本机中都有使用高速缓存

### 输入URL地址到显示主页的过程

#### 查找域名 IP 地址 

##### 查询缓存：浏览器缓存 -> 系统缓存（hosts）-> 路由器缓存 -> DNS服务器缓存

##### DNS解析IP地址

###### DNS查询

#### TCP建立连接

#### 发送HTTP请求报文

#### 服务器处理请求并返回HTTP响应报文

#### 浏览器解析渲染页面

#### 

#####  

## HTTP

- [HTTP](https://cyc2018.github.io/CS-Notes/#/notes/HTTP)

### HTTP 方法

#### GET

##### 获取资源

#### HEAD

##### 获取报文首部

主要用于确认 URL 的有效性以及资源更新的日期时间等。

#### POST

##### 传输实体主体

#### PUT

##### 上传文件

由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。

#### PATCH

##### 对资源进行部分修改

PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。

#### DELETE

##### 删除文件

#### OPTIONS

##### 查询支持的方法

会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。

#### CONNECT

##### 要求在与代理服务器通信时建立隧道

#### TRACE

##### 服务器会将通信路径返回给客户端

### GET 与 POST

#### 作用

##### GET获取资源

##### POST传输实体主体

#### 参数

##### GET参数出现在URL中，URL只支持ASCII码，中文等参数需要编码。

##### POST参数存储在实体主体中，支持标准字符集。

#### 数据大小

##### GET受URL长度限制

##### POST不受限制

#### 安全

##### 安全方法

不修改服务器的数据


###### 安全: GET, HEAD, OPTIONS

###### 不安全: POST, PUT, DELETE

##### 数据安全性

###### POST的安全性比GET高

#### 幂等性

幂等的HTTP方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。

##### 幂等：GET, HEAD, PUT, DELETE

##### 不幂等：POST

#### 可缓存

##### GET、HEAD可缓存

##### POST多数情况不可缓存，PUT、DELETE不可缓存

### 状态码

#### 1XX 信息

##### 100 Continue

###### 目前为止都正常，继续

#### 2XX 成功

##### 200 OK

##### 204 No Content

###### 返回响应报文不含实体主体

##### 206 Partial Content

###### 响应范围请求成功

#### 3XX 重定向

##### 301 Moved Permanently

###### 请求资源已永久移到新位置

##### 302 Found

###### 请求资源临时从不同URI响应

##### 303 See Other

###### 同302，但要求GET方法

##### 304 Not Modified

###### 带条件的请求被允许，但资源未改变

##### 307 Temporary Redirect

###### 同302，但禁止POST改成GET

#### 4XX 客户端错误

##### 400 Bad Request

###### 请求报文中存在语法错误

##### 401 Unauthorized

###### 请求需要用户认证或认证失败

##### 403 Forbidden

###### 请求被拒绝

##### 404 Not Found

#### 5XX 服务器错误

##### 500 Internal Server Error

###### 服务器执行请求时发生错误

##### 502 Bad Gateway

###### 错误的网关，服务器连接过多无法正常响应 

##### 503 Service Unavailable

###### 服务器暂处于超负荷或停机维护

### Cookie

#### Cookie

##### 用户信息保存在客户端

##### 响应报文的Set-Cookie，请求报文的Cookie

#### Session

##### 用户信息保存在服务端

##### Session可存储在服务器的文件、数据库或内存中

##### 生成键Session ID

###### 通过Cookie传递Session ID

###### Cookie被禁用时使用URL重写技术传递Session ID

#### 用途

##### 会话状态管理（登录状态，购物车等）

##### 个性化设置（自定义设置，主题等）

##### 浏览器行为追踪（分析用户行为等）

#### 选择

##### Cookie值存储ASCII码，Session可存储任何类型

##### Session安全性更高，隐私数据在Cookie中需要加密

##### 大型网站不宜使用Session

### 缓存

- [Expires 和 max-age 的区别](https://www.cnblogs.com/yinhaiming/articles/1490811.html)
- [Expires vs max-age, which one takes priority if both are declared in a HTTP response?
](https://stackoverflow.com/questions/7549177/expires-vs-max-age-which-one-takes-priority-if-both-are-declared-in-a-http-resp)

#### 优点

##### 缓解服务器压力

##### 降低客户端获取资源的延迟

#### 实现方法

##### 代理服务器进行缓存

##### 客户端浏览器进行缓存

#### Cache-Control

##### no-cache

###### 强制向源服务器验证再次验证

##### no-store

###### 不缓存任何内容

##### public

###### 可被多个用户使用，存于代理服务器中

##### private

###### 只被单独用户使用，存于浏览器中

##### max-age

###### 请求报文，响应缓存的age需小于指定时间

###### 响应报文，缓存资源在服务器中的保存时间

###### HTTP/1.1中优先处理max-age，HTTP/1.0中忽略max-age

##### expires

###### 缓存资源过期时间

#### 本地缓存验证

##### ETag & If-None-Match

ETag(资源唯一标识)

###### 响应的ETag为资源的唯一标识，ETag放入If-None-Match进行请求验证缓存

##### Last-Modified & If-Modified-Since

###### 响应的Last-Modified指示资源的最后修改时间，修改时间放入If-Modified-Since进行请求验证缓存

##### 缓存有效返回304，无效返回200

### 连接管理

#### 长连接

##### 一次TCP连接，多次HTTP通信

##### HTTP/1.1开始默认长连接

##### 连接时响应头包含Connection : keep-alive, 断开时，使用Connection : close

#### 短连接

##### 一次TCP连接，一次HTTP通信

##### HTTP/1.0默认短连接

#### 流水线

##### 长连接上连续发送请求，无需等待响应

##### 减少延迟

####  

#####  

### HTTPS

让HTTP先与SSL通信，再由SSL和TCP通信，即使用隧道通信。

#### 与HTTP对比

##### HTTP

###### 明文通信，可被窃听

###### 不验证通信方身份，可被伪装

###### 无法证明报文完整性，可被篡改

##### HTTPS

###### 因为需要加密和解密，速度更慢

###### 需要支付证书授权的高额费用

#### 加密（防窃听）

##### 对称密钥加密（共享密钥加密）

###### 加密和解密使用同一密钥

###### 优点：运算速度快

###### 缺点：无法安全将密钥传给通信方

###### 对称加密算法

####### DES

Data Encryption Standard

####### 3DES

######## 对 一块数据 用 三个不同的密钥 进行 三次加密，强度更高。

####### AES

Advanced Encryption Standard

######## 比 DES 更 安全性、效率 和 灵活性

######  

#######  

##### 非对称密钥加密（公开密钥加密）

###### 加密和解密使用不同密钥

###### 发送方使用接受方公开密钥加密，接收方使用私有密钥解密

###### 优点：可安全将公开密钥传给发送方

###### 缺点：运算速度慢

###### 非对称加密算法

####### RSA

####### ECC

######## 比RSA相当的或更高等级 的安全级别

##### HTTPS混合加密机制

###### 保证安全性

####### 使用非对称密钥加密方式加密对称密钥加密方式的密钥

###### 保证效率

####### 使用对称密钥加密方式进行通信

######  

#######  

#### 认证（防伪装）

##### 数字证书

###### 数字证书认证机构CA保证公开密钥在传输过程中不被替换 

###### CA对公开密钥做数字签名，已签名密钥放入证书

#######  

#### 完整性保护（防篡改）

##### SSL 提供报文摘要功能来进行完整性保护

###### HTTP 也提供了 MD5 报文摘要功能，但HTTPS的加密和认证保证不被篡改

##### 数字签名

###### 避免数据在传输过程中被替换

#######  

###### 消息摘要算法

使用哈希函数，产生信息摘要，防篡改

####### MD5

MD5 Message-Digest Algorithm

####### SHA1

Secure Hash Algorithm 1

######## 比MD5安全性更强

####### HMAC

Hash-based Message Authentication Code

######## 输入密钥和消息，输出消息摘要

### HTTP/2

#### 二进制分帧层

##### 报文分 HEADERS 帧和 DATA 帧，都用二进制编码

######  

##### 通信只用一个TCP连接，承载任意数量双向数据流（Stream）

######  

#### 多路复用

##### 解决了HTTP1.x的队首阻塞问题，数据分解为帧发送，根据帧头中流标识符重新组装

######  

#### 服务器推送

##### 客户端请求一个资源，服务端会自动将相关资源一起发送

######  

#### 首部压缩

##### 维护和更新一个首部字段表，避免传输重复字段，并编码进行压缩 

######  

### HTTP1.1新特性 

#### 默认长连接，支持流水线

#### 新增更多的缓存控制策略

##### max-age，If-Match, If-None-Match

#### 新增多个状态响应码

##### 100

#### 新增Host头字段，支持虚拟主机

一台服务器多个域名

#### 新增range头字段，支持断点续传

## Socket

- [Socket](https://cyc2018.github.io/CS-Notes/#/notes/Socket)

### I/O 模型

#### IO操作两阶段

IO中数据先拷贝到内核缓冲区，再从缓冲区拷贝到应用程序地址空间。

##### 等待数据准备好

##### 数据从内核拷贝到进程中

#### 5种I/O 模型

##### 阻塞式I/O

###### 1、2阶段都阻塞，CPU利用率高

#######  

##### 非阻塞式I/O

###### 1阶段轮询，2阶段阻塞，CPU利用率低

#######  

##### I/O复用

###### 1阶段阻塞在select，2阶段阻塞，多连接时开销小

#######  

##### 信号驱动I/O

###### 1阶段非阻塞，2阶段阻塞，CPU利用率高

#######  

##### 异步I/O

###### 1、2阶段都非阻塞

#######  

#### 阻塞与非阻塞

##### 1阶段

#### 同步与异步

##### 2阶段

####  

#####  

### 多路复用

#### select

```
int select(int maxfd, fd_set *readset, fd_set *writeset,
           fd_set *exceptset, const struct timeval *timeout);
/*
maxfd: 监视对象文件描述符数量
readset: 将所有关注「是否存在待读取数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。
writeset: 将所有关注「是否可传输无阻塞数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。
exceptset: 传递关注「是否发生异常」的文件描述符注册到 fd_set 型变量，并其地址值。
timeout: 为防止陷入无限阻塞的状态，传递超时(time-out)信息
返回值: 发生错误时返回 -1,超时时返回0。成功返回大于0的值，该值是发生事件的文件描述符数。
*/
```

##### fd_set数组

###### 下标对应文件描述符 fd

###### 值为1监视，为0不监视

##### readset、writeset、exceptset 对应监视读、写、异常的fd_set数组

##### timeout

###### select阻塞超时时间

##### select调用

###### fd_set中有变动的保持1，无变动的置0

#######  

###### 成功返回大于0，出错返回-1，超时返回0

#####  

######  

```
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>
#include <sys/select.h>
#define BUF_SIZE 30

int main(int argc, char *argv[])
{
    fd_set reads, temps;
    int result, str_len;
    char buf[BUF_SIZE];
    struct timeval timeout;

    FD_ZERO(&reads);   //初始化变量
    FD_SET(0, &reads); //将文件描述符0对应的位设置为1

    /*
    timeout.tv_sec=5;
    timeout.tv_usec=5000;
    */

    while (1)
    {
        temps = reads; //为了防止调用了select 函数后，位的内容改变，先提前存一下
        timeout.tv_sec = 5;
        timeout.tv_usec = 0;
        result = select(1, &temps, 0, 0, &timeout); //如果控制台输入数据，则返回大于0的数，没有就会超时
        if (result == -1)
        {
            puts("select error!");
            break;
        }
        else if (result == 0)
        {
            puts("Time-out!");
        }
        else
        {
            if (FD_ISSET(0, &temps)) //验证发生变化的值是否是标准输入端
            {
                str_len = read(0, buf, BUF_SIZE);
                buf[str_len] = 0;
                printf("message from console: %s", buf);
            }
        }
    }
    return 0;
}
```

#### poll

```
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

##### fd 数量没限制，select限制为1024

#### epoll

##### 仅向操作系统传递一次监视对象，监视范围或内容发生变化时只通知发生变化的事项

##### epoll_create

###### 创建fd保存空间[epoll例程]

##### epoll_ctl

###### 向内核注册或更改 fd

##### epoll_wait

###### 从内核返回发生变化 fd

##### 优点

###### fd 从进程向内核缓冲区只拷贝一次， select 每次调用都拷贝

epoll 仅向操作系统传递一次监视对象，每次调用 select 函数都会向操作系统传递监视对象信息

###### 只需遍历就绪的 fd， select 遍历所有 fd

###### 没 fd 数量限制

##### 工作模式

###### LT（Level Trigger）

####### 只要输入缓冲有数据，就会一直通知该事件

###### ET（Edge Trigger）

####### 事件只通知一次，即使输入缓冲中还留有数据，也不再通知

###### 对比

####### ET减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。

####### ET可以分离接收数据和处理数据的时间点，更灵活性

### Java NIO
