# 数据结构与算法

<!--Note-->
## 资料

- [剑指 Offer 题解](https://cyc2018.github.io/CS-Notes/#/notes/剑指%20offer%20题解)
- [Leetcode 题解](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20题解)
- [算法](https://cyc2018.github.io/CS-Notes/#/notes/算法)
- 《算法》
- 《剑指 Offer》
- 《程序员代码面试指南》
- 《挑战程序设计竞赛》
- [Leetcode](https://leetcode.com/problemset/algorithms/)
- [玩转算法面试 从真题到思维全面提升算法思维](https://coding.imooc.com/class/82.html)
<!--/Note-->

## 算法思想

<!--Note-->
### 数学模型

#### 1.近似

使用 ~f(N) 来表示随着N的增大除以 f(N) 的结果趋近于1的函数。例如，*N³/6-N²/2+N/3 ~ N³/6* 。

#### 2.增长数量级

将程序和它实现的算法隔离开来，这与它是由Java实现或是运行在某台计算机上无关。例如，*N³/6-N²/2+N/3* 的增长数量级为 *O(N³)* 。

#### 3.内循环

执行最频繁的指令决定了程序执行的总时间，这些指令称为程序的内循环。

#### 4.成本模型

由内循环中的操作确定，来评估算法的性质。例如，3-sum问题的成本模型是访问数组元素的次数。

### 注意事项

#### 1.大常数

在求近似时，如果低级项中的常数系数很大，那么该近似就是错误的。

#### 2.非决定性的内循环

有些程序的内循环之外也有大量指令需要考虑。

#### 3.指令时间

计算机系统会使用**缓存**技术来组织内存，那么访问数组中不相邻元素所需的时间可能会很长。

#### 4.对最坏情况下的性能的保证

有些应用程序要求程序对于任意输入的运行时间均小于某个指定的上限。

#### 5.随机化算法

通过随机打乱输入，去除算法对输入的依赖，为性能提供保证。

#### 6.均摊分析

将所有操作的总成本除以操作总数来将成本均摊。

### ThreeSum

ThreeSum用于统计一个数组中和为0的三元组数量。
```
public interface ThreeSum {
	int count(int[] a);
}
```

#### 1.ThreeSumSlow

内循环为`if(a[i] + a[j]+ a[k] == 0)`语句，总执行次数为 *N(N-1)(N-2) = N³/6-N²/2+N/3* ，近似为 *~N³/6* ，增长数量级为 *O(N³)* 。

```
public class ThreeSumSlow implements ThreeSum {
	@Override
	public int count(int[] a) {
		int N = a.length;
		int cnt = 0;
		for(int i = 0; i < N; i++)
			for(int j = i+1; j < N; j++)
				for(int k = j+1; k< N; k++)
					if(a[i] + a[j]+ a[k] == 0)
						cnt++;
		return cnt;
	}
```

#### 2.ThreeSumBinarySearch

将数组进行排序，对两个元素求和，并用二分查找方法查找是否存在该和的相反数，如果存在，就说明存在和为 0 的三元组。

应该注意的是，只有数组不含有相同元素才能使用这种解法，否则二分查找的结果会出错。

该方法可以将 ThreeSum 算法增长数量级降低为 *O(N²logN)*。

```
public class ThreeSumBinarySearch implements ThreeSum{
	@Override
	public int count(int[] a) {
		Arrays.sort(a);
		int N = a.length;
		int cnt = 0;
		for(int i = 0; i < N; i++)
			for(int j = i+1; j < N; j++)
				if(BinarySearch.rank(-a[i]-a[j], a) > j)
					cnt++;
		return cnt;
	}
```

```
public class BinarySearch {
	public static int rank(int key, int[] a) {
		int lo = 0, hi = a.length - 1;
		while(lo <= hi) {
			int min = lo + (hi - lo) / 2;
			if (key < a[min]) hi = min - 1;
			else if (key > a[min]) lo = min + 1;
			else return min;
		}
		return -1;
	}
}
```

#### 3.ThreeSumTwoPointer

更有效的方法是先将数组排序，然后使用双指针进行查找，时间复杂度为 *O(N²)*。

同样不适用与数组存在重复元素的情况。

```
public class ThreeSumTwoPointer implements ThreeSum {

    @Override
    public int count(int[] nums) {
        int N = nums.length;
        int cnt = 0;
        Arrays.sort(nums);
        for (int i = 0; i < N - 2; i++) {
            int l = i + 1, h = N - 1, target = -nums[i];
            while (l < h) {
                int sum = nums[l] + nums[h];
                if (sum == target) {
                    cnt++;
                    l++;
                    h--;
                } else if (sum < target) {
                    l++;
                } else {
                    h--;
                }
            }
        }
        return cnt;
    }
}
```

### 倍率实验

如果 *T(N) ~ aNᵇlgN* ，那么 *T(2N)/T(N) ~ 2ᵇ* 。

例如对于暴力的 ThreeSum 算法，近似时间为  *~N³/6* 。进行如下实验：多次运行该算法，每次取的 N 值为前一次的两倍，统计每次执行的时间，并统计本次运行时间与前一次运行时间的比值，得到如下结果：

N	 |Time(ms)|Ratio
-----|--------|-----
500	 |48	  |/
1000 |320	  |6.7
2000 |555	  |1.7
4000 |4105	  |7.4
8000 |33575	  |8.2
16000|268909  |8.0

可以看到，`T(2*N)/T(N) ~ 2^3`，因此可以确定 `T(N) ~ a*N^3*logN`。

```
public class DoublingRatio {
	public static double timeTrial(int N) {
		int MAX = 1000000;
		int[] a = new int[N];
		for(int i = 0; i < N; i++) {
			a[i] = StdRandom.uniform(-MAX, MAX);
		}
		Stopwatch timer = new Stopwatch();
		ThreeSumBinarySearch threesum = new ThreeSumBinarySearch();
		threesum.count(a);
		return timer.elapsedTime();
	}
}
```

```
public class Stopwatch {
	private final long start;
	public Stopwatch() {
		start = System.currentTimeMillis();
	}
	public double elapsedTime() {
		long now = System.currentTimeMillis();
		return (now - start) / 1000.0;
	}
}
```





<!--/Note-->

### 排序

<!--Note-->
#### 小结

##### 1.排序算法的比较

算法|稳定性|时间复杂度|空间复杂度|备注
:-:|:-:|:-:|:-:|:-:
选择排序|×|N²|1|运行时间与输入无关，数据移动最少|
冒泡排序|√|N²|1||
插入排序|√|N~N²|1|时间复杂度和初始顺序有关|
希尔排序|×|	N 的若干倍乘于递增序列的长度|logN|改进版插入排序|
快速排序|×|NlogN|logN|运行效率由概率提供保证|
三向切分快速排序|×|N~NlogN|logN|适用于有大量重复主键|
归并排序|√|NlogN|N||
堆排序|×|NlogN|1|无法利用局部性原理|

**快速排序是最快的通用排序算法**，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为  *~cNlogN* ，这里的 c 比其它线性对数级别的排序算法都要小。

使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。

##### 2.指针排序

我们使用的方法被称为指针排序，因为只处理元素的引用而不移动数据本身。Java中的指针操作是隐式的，除了原始数据类型之外，操作的总是数据的引用（指针），而非数据本身。

##### 3.稳定性

如果一个排序算法能够保留数组中重复元素的相对位置则被称为是稳定的。如果稳定性很重要而空间又不是问题，归并排序可能是最好的。

##### 4.将原始类型数据排序

将一大组数排序时，跳过引用可以节省存储引用所需的空间和通过引用来访问数据的成本。把Compara接口替换为原始数据类型和重定义less()方法，可以将原始类型数据更快地排序。

##### 5.Java的排序算法实现
Java主要排序方法为 java.util.Arrays.sort()。对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序，也暗示着用速度和空间（对于原始数据类型）来换取稳定性（对于引用类型）。




<!--/Note-->

#### 选择排序

<!--Note-->
##### 选择排序

每次将当前元素与自它起右侧选择最小元素进行交换。

- *~N²/2* 次比较和 *~N* 交换。

- 运行时间与输入无关。数据移动最少。对有序和乱序数组排序时间相同。

```
public class Selection {
	public void sort(int[] a) {
		int N = a.length;
		for (int i = 0; i < N; i++) {
			int min = i;
			for (int j = i+1; j < N; j++) {
				if (a[j] < a[min]) {
                	min = j;
                }
			swap(a, i, min);
            }
		}
	}
}
```
<!--/Note-->

#####  

#### 冒泡排序

<!--Note-->
##### 冒泡排序

从左到右不断交换相邻逆序的元素，让未排序的最大元素上浮到右侧。

```
public class Bubble{
	public void sort(int[] a) {
		int N = a.length;
		for (int i = N - 1; i > 0; i--) { 
			for (int j = 0; j < i; j++) {
				if (a[j+1] < a[j]) {
                	swap(a, j, j+1);
                }
            }
        }
	}
}
```
<!--/Note-->

#####  

#### 插入排序

<!--Note-->
##### 插入排序

每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。

- 插入排序的时间复杂度取决于数组的初始顺序：
	- 平均情况下插入排序需要 *~N²/4* 比较以及 *~N²/4* 次交换；
	- 最坏的情况是数组是倒序的,需要 *~N²/2* 比较以及 *~N²/2* 次交换；
	- 最好的情况是数组已经有序了,需要 *N-1* 次比较和 *0* 次交换。

```
public class Insertion {
	public void sort(int[] a) {
		int N = a.length;
		for (int i = 1; i < N; i++) {
			for (int j = i; j > 0; j--) {
				if (a[j] < a[j - 1]) {
                	swap(a, j, j - 1);
                } else {
                	break;
                }
            }
        }
	}
}
```
<!--/Note-->

#####  

#### 希尔排序

<!--Note-->
##### 希尔排序

希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，直到 h=1。

- 希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, ... 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。

- 比前面介绍的排序快得多，而且数组越大，优势越大。但后面介绍的排序，除了对于很大的N，只会比希尔排序快两倍。

```
public class Shell {
	public void sort(int[] a) {
		int N = a.length;
		int h = 1;
		if (h < N / 3) h = 3 * h + 1; //1, 4, 13, 40, 121, 364, 1093, ...
		while (h >= 1){	
			for (int i = h; i < N; i++) {
				for (int j = i; j >= h && a[j] < a[j-h]; j -= h) {
					swap(a, j, j-h);
				}
			}
			h = h / 3;
		}		
	}
}
```
<!--/Note-->

#####  

#### 归并排序

##### 归并方法 

<!--Note-->
####### 1.原地归并的抽象方法

归并方法将数组中两个已经排序的部分归并成一个。

```
public abstract class MergeSor{
	private int[] aux;
	
	private void merge(int[] a, int lo, int mid, int hi) {
		int i = lo, j = mid + 1;
		
		for (int k = lo; k <= hi; k++)
			aux[k] = a[k];
		
		for (int k = l; k <= hi; k++) {
			if (i > mid) {
            	a[k] = aux[j++];
			} else if (j > hi) { 
            	a[k] = aux[i++];
			} else if (aux[j] < aux[i]) { 
            	a[k] = aux[j++];
			} else { 
            	a[k] = aux[i++]; // 保证稳定性
			}
        }	
	}
}
```
<!--/Note-->

######  

##### 自顶向下归并排序 

<!--Note-->
####### 2.自顶向下的归并排序

将一个大数组分成两个小数组去求解。

- 1/2NlgN 至 NlgN 次比较。最多访问数组 6NlgN。

```
public class UptoDownMerge{
	public void sort(int[] a) {
		aux = new int[a.length]; 
		sort(a, 0, a.length-1);
	}
	
	public void sort(int[] a, int lo, int hi) {
		if (hi <= lo) return;
		int mid = lo + (hi - lo) / 2;
		sort(a, lo, mid);
		sort(a, mid+1, hi);
		merge(a, lo, mid, hi);
	}
}
```
<!--/Note-->

######  

##### 自底向上归并排序 

<!--Note-->
####### 3.自底向上的归并排序

先归并那些微型数组，然后成对归并得到的微型数组。

- 1/2NlgN 至 NlgN 次比较。最多访问数组 6NlgN 。

```
public class DowntoUpMerge {
	public void sort(int[] a) {
		int N = a.length;
		aux = new int[N];
		for(int len = 1; len < N; len *= 2) {
        	int sz = len + len;
			for(int lo = 0; lo < N - len; lo += sz) {
				merge(a, lo, lo + len - 1, Math.min(lo + sz - 1, N -  1));
			}
		}
	}
}
```
<!--/Note-->

######  

#### 快速排序

##### 切分

```
private int partition(int[] a, int lo, int hi) {
	int i = lo, j = hi + 1;
    while (true) {
    	while (i < hi && a[++i] < a[lo]); 
    	while (j > lo && a[--i] > a[lo]);
    	if (i >= j) break;
    	swap(a, i, j);
    }
    swap(a, lo, j);
    return j;
}
```

######  

##### 快速排序

<!--Note-->
####### 1.基本排序

快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序后整个数组就有序了。

- 快速排序是原地排序，使用的空间是`O(1)`，但真正消耗空间的是递归调用，平均空间复杂度为`O(logn)`。

- 排序所需时间和 *NlgN* 成正比。
  -	最好情况是每次都正好将数组对半分。需要 *~NlgN* 次比较。
  - 平均需要 *~2NlnN ≈ 1.39NlgN* 次比较和 *1/6* 次交换。
  - 最坏情况下，第一次从最小元素切分，第二次从第二小元素切分，如此这般，最多需要约 *N²/2* 次比较，但**随机打乱数组能够预防这种情况**。

```
public class QuickSort{
	public void sort(int[] a) {
		shuffle(a);
		sort(a, 0, a.length - 1);
	}
	
	private void sort(int[] a, int lo, int hi) {
		if (hi <= lo) return;
		int j = partition(a, lo, hi);
		sort(a, lo, j-1);
		sort(a, j+1, hi);
	}
	
	private void shuffle(int[] a) {
		List<Comparable> list = Arrays.asList(a);
		Collections.shuffle(list);
		list.toArray(a);
	}
}
```
<!--/Note-->

######  

##### 三向切分排序

<!--Note-->
####### 2.三向切分

将数组分为三部分，分别对应小于、等于和大于切分元素的数组元素。

- 对于包含**大量重复元素**的数组，它将排序时间从线性对数级降低到线性级别。
- 需要 *~(2ln2)NH* 次比较。其中 *H* 为由主键值出现频率定义的香农信息量。

```
public class ThreeWayQuickSort {
    public void sort(int[] nums, int l, int h) {
        if (h <= l) {
            return;
        }
        int lt = l, i = l + 1, gt = h;
        int v = nums[l];
        while (i <= gt) {
            if (nums[i] < v) {
                swap(nums, lt++, i++);
            } else if (nums[i] > v) {
                swap(nums, i, gt--);
            } else {
                i++;
            }
        }
        sort(nums, l, lt - 1);
        sort(nums, gt + 1, h);
    }
}

```
<!--/Note-->

##### 快速选择

<!--Note-->
######## 4.基于切分的快速选择算法

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。

可以利用这个特性找出数组的第 `k` 个元素。

时间复杂度为 *O(N)*，假设每次能将数组二分，那么比较的总次数为 `(N+N/2+N/4+..)`，直到找到第 `k` 个元素，这个和显然小于 `2N`。

```
public class QuickSelect{
	public int select(int a[], int k) {
		int lo = 0, hi = a.length - 1;
		while (hi > 1) {
			int j = partition(a, lo, hi);
			if (k == j) return a[k];
			else if (k < j) hi = j - 1;
			else lo = j + 1;
		}
		return a[k];
	}
}
```

<!--/Note-->

#### 堆排序

##### 基于堆的优先队列

支持*删除最大元素*和*插入元素*操作的数据结构叫做优先队列。

###### 堆的定义

<!--Note-->
######### 1.堆的定义

当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。因此根结点是堆有序二叉树中的最大结点。

二叉堆简称堆，是一组能够用堆有序的完全二叉树排列的元素，并在数组中逐层存储（不使用数组第一个位置[0]）。

堆中，位置k的结点的父结点位置为k/2,两个子结点的位置分别为2k和2k+1。

- 堆中最长路径为 *~lgN* ，因此优先队列所需比较次数和 *logN* 成正比。

```
public class Heap<T extends Comparable<T>>{
	private T[] heap;
	private int N = 0;
	
	public Heap(int maxN){
		heap = (T[]) new Comparable[maxN + 1];
	}
	
	public boolean isEmpty() {
		return N == 0;
	}
	
	public int size() {
		return N;
	}
	
	private boolean less(int i, int j) {
		return heap[i].compareTo(heap[j]) < 0;
	}
	
	private void swap(int i, int j) {
		T t = heap[i];
		heap[i] = heap[j];
		heap[j] = t;
	}
}
```
<!--/Note-->

###### 上浮

<!--Note-->
######### 2.上浮

在堆中，当一个结点比父结点大，那么需要交换这个两个结点。交换后还可能比它新的父结点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。

```
private void swim(int k) {
	while (k > 1 && less(k/2, k)) {
		swap(k/2, k);
		k = k/2;
	}
}
```
<!--/Note-->

#######  

###### 下沉

<!--Note-->
######### 3.下沉

在堆中，当一个结点比子结点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个结点如果有两个子结点，应当与两个子结点中最大那个结点进行交换。

```
private void sink(int k) {
	while (2*k <= N) {
		int j = 2*k;
		if (j < N && less(j, j+1)) 
			j++;
		if (!less(k, j)) break;
		swap(k, j);
		k = j;
	}
}
```
<!--/Note-->

#######  

###### 插入元素

<!--Note-->
######### 4.插入元素

将新元素放到数组末尾，然后上浮到合适的位置。

- 插入元素操作只需不超过 *(lgN+1)* 次比较。

```
public void insert(T v) {
	heap[++N] = v;
	swim(N);
}
```

<!--/Note-->

###### 删除最大元素

<!--Note-->
######### 5.删除最大元素

从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。

- 删除最大元素操作需要不超过 *(2lgN)* 次比较。

```
public T delMax() {
	T max = heap[1];
	swap(1, N--);
	heap[N+1] = null;
	sink(1);
	return max;
}
```
<!--/Note-->

##### 堆排序

<!--Note-->
####### 堆排序

把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。

######## 1.堆的构造

从右至左进行下沉操作。叶子结点不需要进行下沉操作，可以忽略叶子结点的元素，因此只需要遍历一半的元素即可。
遍历`N/2`次，每次下沉`< logN`次，因此堆构造的时间复杂度约为`O(N)`。

######## 2.下沉排序

将堆中的最大元素删除，然后放入对缩小后数组空出的位置。


- 堆排序只需要至少 *(2NlgN+2N)* 次比较（以及一半次数的交换）。

- 现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。


```
 /* 数组第 0 个位置不能有元素 */
public class HeapSort {
	public void sort(int[] a) {
		int N = a.length - 1;
        
        // 构造堆，遍历 N/2 次，每次下沉 <logN 次，故复杂度为 O(N)
		for (int k = N / 2; k >= 1; k--)
			sink(a, k, N);
        
        // 下沉排序 
		while(N > 1) {
			swap(a, 1, N--);
			sink(a, 1, N);
		}
	}
	
    // 数值小则下沉 
	private void sink(int[] a, int k, int N) {
		while (2 * k <= N) {
			int j = 2 * k;
			if (j < N && a[j] < a[j+1])) j++;
			if (a[k] >= a[j])) break;
			swap(a, k, j);
			k = j;
		}
	}
}

```
<!--/Note-->

######  

### 栈和队列

#### 栈

<!--Note-->
##### 栈

```
public interface Stack<Item> extends Iterable<Item> {
	boolean isEmpty();
	int size();
	Stack<Item> push(Item item);
	Item pop() throws Exception;
}
```

###### 1.数组实现

```
public class ResizingArrayStack<Item> implements Stack<Item> {
	private Item[] a = (Item[]) new Object[1];
	private int N = 0;
	
	@Override
	public boolean isEmpty() {
		return N == 0;
	}
	
	@Override
	public int size() {
		return N;
	}
	
	private void resize(int max) {
		Item[] temp = (Item[]) new Object[max];
		for(int i = 0; i < N; i++) {
			temp[i] = a[i];
		}
		a = temp;
	}
	
	@Override
	public Stack<Item> push(Item item) {
		if (N == a.length) resize(2*N);
		a[N++] = item;
		return this;
	}
	
	@Override
	public Item pop() throws Exception {
		if (isEmpty())
			throw new Exception("Stack is empty!");
		Item item = a[--N];
		a[N] = null; // 避免对象游离
		if (N > 0 && N == a.length/4)
			resize(a.length/2);
		return item;
	}
	
	@Override
	public Iterator<Item> iterator(){
		// 返回逆序遍历的迭代器
		return new Iterator<Item>() {
			private int i = N;
			
			public boolean hasNext() {
				return i > 0;
			}
			
			public Item next() {
				return a[--i];
			}
			
			public void remove() {}
		};
	}
}
```

###### 2.链表实现

```
public class ListStack<Item> implements Stack<Item> {
	private Node top = null;
	private int N = 0;
	private class Node{
		Item item;
		Node next;
	}
	
	@Override
	public boolean isEmpty() {
		return top == null;
	}
	
	@Override
	public int size() {
		return N;
	}
	
	@Override
	public Stack<Item> push(Item item) {
		Node newTop = new Node();
		newTop.item = item;
		newTop.next = top;
		top = newTop;
		N++;
		
		return this;
	}
	
	@Override
	public Item pop() throws Exception {
		if (isEmpty())
			throw new Exception("Stack is empty!");
		
		Item item = top.item;
		top = top.next;
		N--;
		
		return item;
	}
	
	@Override
	public Iterator<Item> iterator() {
		return new Iterator<Item>() {
			// 返回链表遍历的迭代器
			private Node current = top;
			
			public boolean hasNext() {
				return current != null; // current.next != null; 错误
			}
			
			public Item next() {
				Item item = current.item;
				current = current.next;
				return item;
			}
	        
			public void remove() {}
		};
	}
}
```





<!--/Note-->

#### 队列

<!--Note-->
##### 队列

```
public interface Queue<Item> extends Iterable<Item> {
	boolean isEmpty();
	int size();
	Queue<Item> enqueue(Item item);
	Item dequeue() throws Exception;
}
```

```
public class ListQueue<Item> implements Queue<Item> {
	private Node first;
	private Node last;
	private int N = 0;
	private class Node {
		Item item;
		Node next;
	}
	
	@Override
	public boolean isEmpty() {
		return first == null;
	}
	
	@Override
	public int size() {
		return N;
	}
	
	@Override
	public Queue<Item> enqueue(Item item){
		Node newNode = new Node();
		newNode.item = item;
		newNode.next = null;
		if (isEmpty()) 
			first = newNode;
		else
			last.next = newNode;
		last = newNode;
		return this;
	}
	
	@Override
	public Item dequeue() throws Exception {
		if (isEmpty())
			throw new Exception("Queue is empty!");
		
		Item item = first.item;
		first = first.next;
		if (isEmpty())
			last = null;
		N--;
		return item;
	}
	
	@Override
	public Iterator<Item> iterator(){
		return new Iterator<Item>() {
			private Node current = first;
			
			public boolean hasNext() {
				return current != null;
			}
			
			public Item next() {
				Item item = current.item;
				current = current.next;
				return item;
			}
			
			public void remove() {}
		};
	}
}
```
<!--/Note-->

### 查找

<!--Note-->
##### 符号表实现的成本总结

算法（数据结构）|查找|插入|是否支持有序操作
 -|-|-|-
 顺序查找（无序链表）|N|N|否
 二分查找（有序数组）|logN|N|是
 二叉树查找（BST）|logN|logN|是
 2-3树查找（红黑树）|logN|logN|是
 拉链法（链表数组）|N/M|N/M|否
 线性探测法（并行数组）|1|1|否
 
- 散列表代码更简单，查找时间最优；二叉查找树抽象结构更简单，红黑树支持的操作更多。 
- *根据经验法则，优先选择散列表，当需要有序性操作时才选择红黑树。*

##### Java的符号表实现

java.util.TreeMap：红黑树
java.util.HashMap：拉链法的散列表

-
<!--/Note-->

#### 简单符号表

<!--Note-->
##### 符号表(Symbol Table)

符号表存储键值对的数据结构，支持两种操作：插入（put）即将一组新的键值对存入表中；查找（get），即根据给定的键得到相应的值。

符号表分为有序和无序两种，有序符号表主要指支持 min()、max() 等根据键的大小关系来实现的操作。有序符号表的键需要实现 Comparable 接口。

```
public interface UnorderST<Key, Value> {
	void put(Key key, Value val);
	Value get(Key key);
	void delete(Key key);
	int size();
	//Iterable<Key> keys();
}
```

```
public interface OrderST<Key extends Comparable<Key>, Value> {
	void put(Key key, Value val);
	Value get(Key key);
	int size();
	int rank(Key key);
	Key min();
	Key max();
	Key select(int k);
	Key ceiling(Key key);
	Key floor(Key key);
	void delete(Key key);
	Iterable<Key> keys(Key lo, Key hi);  
}
```


 
 
 
 
<!--/Note-->

##### 无序链表中的顺序查找

<!--Note-->
###### 无序链表中的顺序查找

- 未命中的查找和插入操作都需要N次比较。命中的查找在最坏情况下需要N次比较。

```
public class SequentialSearchST<Key, Value> implements UnorderST<Key, Value> {
	private Node first;
	
	private class Node{
		Key key;
		Value val;
		Node next;
		
		public Node(Key key, Value val, Node next) {
			this.key = key;
			this.val = val;
			this.next = next;
		}
	}
	
	@Override
	public void put(Key key, Value val) {
		for (Node x = first; x != null; x = x.next) {
			if (key.equals(x.key)) {
				x.val = val;
				return;
			}	
		}
		first = new Node(key, val, first);
	}
	
	@Override
	public Value get(Key key) {
		for (Node x = first; x != null; x = x.next) {
			if (key.equals(x.key))
				return x.val;
		}
		return null;
	}
	
	@Override
	public int size() {
		int cnt = 0;
		for (Node x = first; x != null; x = x.next) 
			cnt++;
		return cnt;
	}
	
	@Override
	public void delete(Key key) {
		Node pre = first;
		for (Node x = first; x != null; x = x.next) {
			if (key.equals(x.key)) {
				pre.next = x.next;
				return;
			}
			pre = x;
		}
	}
}
```
<!--/Note-->

######  

##### 有序数组中的二分查找

<!--Note-->
###### 有序数组中的二分查找

使用一对平行数组，一个存储键一个存储值。

二分查找的 rank() 方法至关重要，当键在表中时，返回该键的位置，即表中小于它的键的数量；当键不在表中时，还是返回表中小于它的键的数量（*rank()实际返回的就是向上取整的下标*）。

- 二分查找最多需要 *（logN+1）* 比较。有序数组中插入一个新元素在最坏情况下需要访问 *~2N* 次数组。

```
public class BinarySearchST<Key extends Comparable<Key>, Value> implements OrderST<Key, Value> {
	private Key[] keys;
	private Value[] vals;
	private int N;
	
	public BinarySearchST(int capacity) {
		keys = (Key[]) new Comparable[capacity];
		vals = (Value[]) new Object[capacity]; 
	}
	
	@Override
	public int rank(Key key) {
		// 找出小于指定键的键的数量
		int lo = 0, hi = N - 1;
		while (lo <= hi) {
			int mid = lo + (hi - lo) / 2;
			int cmp = key.compareTo(keys[mid]);
			if (cmp > 0)
				lo = mid + 1;
			else if (cmp < 0)
				hi = mid - 1;
			else 
				return mid;
		}
		return lo;
	}
	
	@Override
	public void put(Key key, Value val) {
		int i = rank(key);
		// 如果找到已经存在的节点键为 key，就更新这个节点的值为 value
		if (i < N && key.compareTo(keys[i]) == 0) {
			vals[i] = val;
			return;
		}
		// 否则在数组中插入新的节点，需要先将插入位置之后的元素都向后移动一个位置
		for (int j = N; j > i; j--) {
			keys[j] = keys[j-1];
			vals[j] = vals[j-1];
		}
		keys[i] = key;
		vals[i] = val;
		N++;
	}
	
	@Override
	public Value get(Key key) {
		int i = rank(key);
		if (i < N && key.compareTo(keys[i]) == 0) 
			return vals[i];
		else 
			return null;
	}
	
	@Override
	public int size() {
		return N;
	}
	
	@Override
	public Key min() {
		return keys[0];
	}
	
	@Override
	public Key max() {
		return keys[N-1];
	}
	
	@Override 
	public Key select(int k) {
		return keys[k];
	}
	
	@Override
	public Key ceiling(Key key) {
		//向上取整
		return keys[rank(key)];
	}
	
	@Override
	public Key floor(Key key) {
		//向下取整
		int i = rank(key);
		if (i < N && key.compareTo(keys[i]) == 0)
			return keys[i];
		else
			return keys[i-1];
	}
	
	@Override
	public void delete(Key key) {
		int i = rank(key);
		if (i < N && key.compareTo(keys[i]) == 0) {
			for (int j = i; j < N - 1; j++) {
				keys[j] = keys[j+1];
				vals[j] = vals[j+1];
			}
			keys[N-1] = null;
			vals[N-1] = null;
			N--;
		}
	}
	
	@Override
	public Iterable<Key> keys(Key lo, Key hi){
		Queue<Key> q = new ListQueue<Key>();
		for (int i = rank(lo); i < rank(hi); i++) 
			q.enqueue(keys[i]);
		if (hi.compareTo(keys[rank(hi)]) == 0)
			q.enqueue(hi);
		return q;
	}
}
```
<!--/Note-->

######  

#### 二叉查找树

二叉查找树（BST）是一颗二叉树，其中每个结点都含有一个Comparable的键（以及关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。

BST 有一个重要性质，就是它的中序遍历结果递增排序。

基于二叉查找树的符号表：

```
public class BST<Key extends Comparable<Key>, Value> implements OrderST<Key, Value> {
	private Node root;
	
	private class Node{
		Key key;
		Value val;
		Node left, right;
		int N;
		
		Node(Key key, Value val, int N){
			this.key = key;
			this.val = val;
			this.N = N;
		}
	}
	
	@Override
	public int size() {
		return size(root);
	}
	
	private int size(Node x) {
		if (x == null) return 0;
		else return x.N;
	}
}
```

##### 查找

- 如果树是空的，则查找未命中；
- 如果被查找的键和根节点的键相等，查找命中；
- 否则递归地在适当的子树中查找：如果被查找的键较小就在左子树中查找，较大就在右子树中查找。

```

	@Override
	public Value get(Key key) {
		return get(root, key);
	}
	
	private Value get(Node x, Key key) {
		if (x == null) return null;
		int cmp = key.compareTo(x.key);
		if (cmp < 0) return get(x.left, key);
		else if (cmp > 0) return get(x.right, key);
		else return x.val;
	}
```

##### 插入

- 如果树是空的，返回一个含有该键值对的新结点；
- 如果被查找的键小于根结点的键，在左子树中插入该键，否则在右子树中插入该键；
- 递归：沿搜索路径向上更新链接并增加结点计数器的值。

```

	@Override
	public void put(Key key, Value val) {
		root = put(root, key, val);
	}
	
	private Node put(Node x, Key key, Value val) {
		if (x == null) return new Node(key, val, 1);
		int cmp = key.compareTo(x.key);
		if (cmp < 0) x.left = put(x.left, key, val);
		else if (cmp > 0) x.right = put(x.right, key, val);
		else x.val = val;
		x.N = size(x.left) + size(x.right) + 1;
		return x;
	}
```

##### 最大键和最小键

- 如果根结点的左链接为空，那么树中最小键就是根结点；
- 如果左链接非空，那么树中最小键就是左子树中的最小键。

```

    @Override
	public Key min() {
		return min(root).key;
	}
	
	private Node min(Node x) {
		if (x.left == null) return x;
		return min(x.left);
	}
	
	@Override
	public Key max() {
		return max(root).key;
	}
	
	private Node max(Node x) {
		if (x.right == null) return x;
		return max(x.right);
	}
```

##### 向上取整和向下取整

<!--Note-->
######## `floor(key)`：小于等于键的最大键。

- 如果键小于根结点的键，那么floor(key)一定在左子树中；
- 如果键大于根结点的键，那么只要右子树中存在floor(key)则返回，否则根结点为floor(key)。

```

	@Override
	public Key floor(Key key) {
		Node x = floor(root, key);
		if (x == null) return null;
		else return x.key;
	}
	
	private Node floor(Node x, Key key) {
		if (x == null) return null;
		int cmp = key.compareTo(x.key);
		if (cmp == 0) return x;
		else if (cmp < 0) return floor(x.left, key);
		else {
        Node t = floor(x.right, key);
		return t != null ? t : x;
        }
	}
	
	@Override
	public Key ceiling(Key key) {
		Node x = ceiling(root, key);
		if (x == null) return null;
		return x.key;
	}
	
	private Node ceiling(Node x, Key key) {
		if (x == null) return null;
		int cmp = key.compareTo(x.key);
		if (cmp == 0) return x;
		else if (cmp > 0) ceiling(x.right, key);
		else {
        Node t = ceiling(x.left, key);
		return t != null ? t : x;
        }
	}
```
<!--/Note-->

##### 选择和排名

<!--Note-->
######## `select(k)`：返回排名为k的键。

- 如果左子树结点数t大于k，在左子树中查找排名为k的键；
- 如果t等于k，返回根结点的键；
- 如果t小于k，在右子树中查找排名为(k-t-1)的键。

```
	
    @Override
	public Key select(int k) {
		return select(root, k).key;
	}
    
	private Node select(Node x, int k) {
		if (x == null) return null;
		int t = size(x.left);
		if (t > k) return select(x.left, k);
		else if (t < k) return select(x.right, k-t-1);
		else return x;
	}
```

######## `rank(key)`：返回key的排名。

- 如果键等于根结点的键，返回左子树的结点数；
- 如果键小于根结点的键，返回键在左子树中的排名；
- 如果键大于根结点的键，返回左子树结点数加上1（根结点）加上键在右子树中的排名。

```

	@Override
	public int rank(Key key) {
		return rank(root, key);
	}
    
	private int rank(Node x, Key key) {
		if (x == null) return 0;
		int cmp = key.compareTo(x.key);
		if (cmp < 0) return rank(x.left, key);
		else if (cmp > 0) return 1 + size(x.left) + rank(x.right, key);
		else return size(x.left);
	}
```


<!--/Note-->

##### 删除

<!--Note-->
######## `deleteMin()`：删除最小键。

- 不断深入根结点的左子树中直至遇见空链接，将指向该结点的链接指向该结点的右子树。

```

	public void deleteMin() {
		root = deleteMin(root);
	}
    
	private Node deleteMin(Node x) {
		if (x.left == null) return x.right;
		x.left = deleteMin(x.left);
		x.N = size(x.left) + size(x.right) + 1;
		return x;
	}
```

######## `delete(key)`：删除键为key的结点。

- 如果待删除的结点只有一个子树， 那么只需要让指向待删除节点的链接指向唯一的子树即可；
- 否则，让右子树的最小结点替换该结点。

```

	@Override
	public void delete(Key key) {
		root = delete(root, key);
	}
    
	private Node delete(Node x, Key key) {
		if (x == null) return null;
		int cmp = key.compareTo(x.key);
		if (cmp < 0) x.left = delete(x.left, key);
		else if (cmp > 0) x.right = delete(x.right, key);
		else {
			if (x.left == null) return x.right;
			if (x.right == null) return x.left;
			Node t = x;
			x = min(x.right);
			x.left = t.left;
			x.right = deleteMin(t.right);
		}
		x.N = size(x.left) + size(x.right) + 1;
		return x;
	}
```
<!--/Note-->

###### 删除最小键

###### 删除操作

##### 范围查找

<!--Note-->
######## `keys(lo, hi)`：返回给定范围内的键。

- 利用二叉查找树**中序遍历**的结果为递增的特点。

```

	@Override
	public Iterable<Key> keys(Key lo, Key hi) {
		return keys(root, lo, hi);
	}
	public Queue<Key> keys(Node x, Key lo, Key hi){
		Queue<Key> queue = new LinkedList();
		keys(x, queue, lo, hi);
		return queue;
	}
	private void keys(Node x, Queue<Key> queue, Key lo, Key hi){
		if (x == null) return;
		int cmplo = lo.compareTo(x.key);
		int cmphi = hi.compareTo(x.key);
		if (cmplo < 0) keys(x.left, queue, lo, hi);
		if (cmplo <= 0 && cmphi >= 0) queue.add(x.key);
		if (cmphi > 0) keys(x.right, queue, lo, hi);
	}
```
<!--/Note-->

##### 分析

二叉查找树的算法运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。

- 最好的情况下树是完全平衡的，每条空链接和根节点的距离都为 *logN* 。

- 在最坏的情况下树是斜树，树的高度为 *N* 。

- 二叉查找树所有操作在最坏情况下所需的时间都和树的高度成正比。

###### 完全二叉树

###### 斜树

#### 红黑树

<!--Note-->
##### 回答

- JDK 中 TreeMap 和 TreeSet，1.8 之后的 HashMap 和 ConcurrentHashMap
- 介绍二叉查找树、23查找树，再介绍红黑树原理
- 与 B+ 树进行比较

##### 资料

- [红黑树 - 维基百科](https://zh.wikipedia.org/zh-hans/%E7%BA%A2%E9%BB%91%E6%A0%91)
<!--/Note-->

##### 2-3查找树

###### 引入2- 节点和3- 节点

#######  

###### 插入操作

####### 2- 节点

########  

####### 3- 节点

########  

###### 高度不超logN

##### 红黑二叉查找树

###### 红链接为左链接，完美黑色平衡

####### 

###### 左旋转

#######  

###### 右旋转

#######  

###### 颜色转换

#######  

###### 插入

#######  

###### 高度不超2logN

#### B+ 树

- 大规模数据存储中，实现索引查询这样一个实际背景下，**磁盘查找存取的次数往往由树的高度所决定**，二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，B树的各种操作能使B树保持较低的高度，从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率。

- B树与红黑树最大的不同在于，B树的结点可以有许多孩子，从几个到几千个。B树与红黑树很相似，一棵含n个结点的B树的高度也为O（logn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。


[从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)





##### B树

<!--Note-->
####### B树
B树（B-tree）是一种平衡的多路查找树，结点最大的孩子数目称为B树的阶。
一个m阶的B树具有如下属性：
- 如果根结点不是叶结点，则其至少有两个孩子（子树）。
- 每个非根的分支结点都有k-1个元素和k个孩子，每个叶子结点n都有k-1个元素，其中⌈m/2⌉<=k<= m。
- 所有叶子结点都位于同一层次。
- 所有分支结点包含下列信息数据（n,A₀,K₁,A₁,K₂,A₂,...,Kₙ,Aₙ），其中：
	- Kᵢ(i=1,2,...,n)为关键字，且Kᵢ<Kᵢ₊₁;
    - Aᵢ(i=0,2,...,n)为指向子树根结点的指针，且指针Aᵢ所指子树中所有结点的关键字均小于Kᵢ₊₁，但都大于Kᵢ;
    - 关键字的个数必须满足：n(⌈m/2⌉-1<=n<= m-1)。

对于n个关键字的m阶B树，树的高度*h<= log⌈m/2⌉((n+1)/2)+1*。
<!--/Note-->

###### 图为3阶B树，结点结构为（2,A₀,K₁,A₁,K₂,A₂） 

##### B+树

<!--Note-->
####### B+树
一个m阶的B+树和m阶的B树的差异在于：
- 有n棵子树的结点中包含n个关键字；
- 所有的叶子结点包含全部关键字的信息，及指向含有这些关键字记录的指针，叶子结点本身依关键字的大小自小到大顺序链接；
- 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字。

B+树相较于B树的优点：
- **B+-tree的磁盘读写代价更低**：B+-tree的内部结点并没有指向关键字具体信息的指针。
- **B+-tree的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路，导致每一个数据的查询效率相当。
<!--/Note-->

######  

#### LSM

#### AVL

平衡二叉树（AVL树）是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。



#### 散列表（哈希表）

散列表类似于数组，可以把散列值看成数组的索引值。

- 使用散列的查找算法分为两步：
	- 1、用散列函数将被查找的键转化为数组的一个索引。
	- 2、处理碰撞冲突。

- 访问散列表和访问数组元素一样快速，它可以在常数时间内实现查找和插入操作。

- 由于无法通过散列值知道键的大小关系，因此散列表**无法实现有序性操作**。

##### 散列函数

对于一个大小为 M 的散列表，散列函数能够把任意键转换为 [0, M-1] 内的正整数，该正整数即为 hash 值。

- 散列函数应满足三个条件：
	- 一致性——等价的键必然产生相等的散列值；
	- 高效性——计算简便。
	- 均匀性——均匀地散列所有的键。

### 键的类型
对于每种类型的键都需要一个与之对应的散列函数：
- **正整数**：使用除留余数法，选择大小为素数M的数组，对于任意正整数k，计算k除以M的余数。`k%M`能够有效地将键散布在[0, M-1]之间。
- **浮点数**：将键表示为二进制数后使用除留余数法。
- **字符串**：将字符串当作一个N位的R进制值，并将它除以M并取余。R通常取31。
```
int hash = 0;
for (int i = 0; i < s.length(); i++)
	hash = (R * hash + s.charAt(i)) % M;
```
- **组合键**：如果键的类型含有多个整型变量。如
`int hash = (((day * R + month) % M) * R + year) % M;`

### Java的约定
Java令所有数据类型都继承一个能够返回一个32位整数的hashCode()。

如果两个对象的hashCode()方法的返回值相同，这两个对象可能不同，还需用equals()进行判断。

**hashCode()和除留余数法结合返回一个数组索引**。将符号位屏蔽（将一个32位整数变成一个31位非负整数），然后用除留余数法得到一个[0, M-1]之间的整数：
```
private int hash(Key x)
{	return (x.hashCode() & 0x7fffffff) % M;}
```

### 自定义的hashCode()方法
hashCode()方法能够将键平均地散布为所有可能的32位整数。对于任意对象x，可调用x.hashCode()得到一个32位整数值。例如：
```
public class Transaction {

    private final String who;
    private final Date when;
    private final double amount;

    public int hashCode() {
        int hash = 17;
        int R = 31;
        hash = R * hash + who.hashCode();
        hash = R * hash + when.hashCode();
        hash = R * hash + ((Double) amount).hashCode();
        return hash;
    }
}
```

### 软缓存
如果散列值的计算很耗时，可以将每个键的散列值缓存起来，即每个键用一个hash变量来保存hashCode()的返回值。



###### R为何取31

####### 移位和减法取代乘法，获取更好性能：31 * i == (i << 5) - i

###### hashCode()默认取对象内存地址

##### 拉链法

拉链法使用链表来存储 hash 值相同的键，从而解决冲突。

查找需要分两步，首先查找 Key 所在的链表，然后在链表中顺序查找。

- 对于 N 个键，M 条链表 (N>M)，如果哈希函数能够满足均匀性的条件，每条链表的大小趋向于 N/M，因此未命中的查找和插入操作所需要的比较次数为 ~N/M。

```
public class SeparateChainingHashST<Key, Value> {
    private int N;
    private int M;
    private SequentialSearchST<Key, Value>[] st;

    public SeparateChainingHashST() {
        this(997);
    }

    public SeparateChainingHashST(int M) {
        this.M = M;
        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[M];
        for (int i = 0; i < M; i++)
            st[i] = new SequentialSearchST<>();
    }

    private int hash(Key key){
        return (key.hashCode() & 0x7fffffff) % M;
    }

    private Value get(Key key){
        return (Value) st[hash(key)].get(key);
    }

    private void put(Key key, Value val){
        st[hash(key)].put(key, val);
    }
}	
```

######  

##### 线性探测法

线性探测法使用空位来解决冲突，当冲突发生时，向前探测一个空位来存储冲突的键。

- 使用线性探测法，数组的大小 M 应当大于键的个数 N（M>N)。
- α = N/M，把 α 称为使用率。理论证明，当 α 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间。为了保证散列表的性能，应当调整数组的大小，使得 α 在 [1/4, 1/2] 之间。


```
public class LinearProbingHashST<Key, Value> {
    private int N;
    private int M;
    private Key[] keys;
    private Value[] vals;

    public LinearProbingHashST(){
        this(16);
    }
     public LinearProbingHashST(int capacity){
        M = capacity;
        N = 0;
        keys = (Key[]) new Object[M];
        vals = (Value[]) new Object[M];
     }

    private int hash(Key key){
        return (key.hashCode() & 0x7fffffff) % M;
    }

    private void resize(int cap){
        LinearProbingHashST<Key, Value> t;
        t = new LinearProbingHashST<>(cap);
        for (int i = 0; i < M; i++) {
            if (keys[i] != null)
                t.put(keys[i], vals[i]);
        }
        this.keys = t.keys;
        this.vals = t.vals;
        this.M = t.M;
    }

    public void put(Key key, Value val){
        if (N >= M/2) resize(2 * M);

        int i;
        for (i = hash(key); keys[i] != null; i = (i + 1) % M){
            if (keys[i].equals(key)){
                vals[i] = val;
                return;
            }
        }
        keys[i] = key;
        vals[i] = val;
        N++;
    }

    public Value get(Key key){
        for(int i = hash(key); keys[i] != null; i = (i + 1) % M){
            if (keys[i].equals(key))
                return vals[i];
        }
        return null;
    }

    public void delete(Key key){
        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
        int i = hash(key);
        while (!keys[i].equals(key))
            i = (i + 1) % M;
        keys[i] = null;
        vals[i] = null;
        
        // 将之后相连的键值对重新插入
        i = (i + 1) % M;
        while (keys[i] != null){
            Key keyToRedo = keys[i];
            Value valToRedo = vals[i];
            keys[i] = null;
            vals[i] = null;
            N--;
            put(keyToRedo, valToRedo);
            i = (i + 1) % M;
        }
        N--;
        if (N > 0 && N <= M/8) resize(M/2);
    }
}

```

######  

### 字符串

#### 指纹

#### KMP

##### 字符串匹配 

```
int match(String s, String pattern) {
	int i = 0, j = 0;
	int slen = s.length(), plen = p.length();

	while (i < slen && j < plen) {
		if (s.charAt(i) == p.charAt(j)) {
			i++; j++;
		} else {
			// 不匹配时
			// ...（暴力或KMP）
        }
	}
    
    if (j == plen) {
		return i - j;
	} else {
    	return -1;
    }	
}
``````

###### 暴力匹配算法

```
int match(String s, String pattern) {
	int i = 0, j = 0;
	int slen = s.length(), plen = p.length();

	while (i < slen && j < plen) {
		if (s.charAt(i) == p.charAt(j)) {
			i++; j++;
		} else {
			// 不匹配时
            i = i - j + 1;
            j = 0;
        }
	}
    
    if (j == plen) {
		return i - j;
	} else {
    	return -1;
    }	
}
```

###### KMP算法

```
public int kmp(String s, String p) {
    int i = 0, j = 0;
    int slen = s.length(), plen = p.length();

    int[] next = new int[plen];
    getNext(p, next);

    while (i < slen && j < plen) {
        if (s.charAt(i) == p.charAt(j)) {
            i++;
            j++;
        } else {
        	// 不匹配时
            if (next[j] == -1) {
            	// 跟p的第一个字符不匹配
                i++;
            } else {
                j = next[j];
            }
        }
    }

    if (j == plen) {
        return i - j;
    } else {
        return -1;
    }
}
```

        	 





####### 部分匹配值

```
public void getNext(String p, int[] next) {
    int j = 1, k = 0;
    next[0] = -1;
    int len = p.length();

    while (i < len - 1) {
        if (p.charAt(j) == p.charAt(k)) {
            j++;
            k++;
            next[j] = k;
        } else {
            if (next[k] == -1) {
                i++;
                next[j] = 0;
            } else {
                k = next[k];
            }
        }
    }
}
```
```

i BBC ABCDAB ABCDABCDABDE 
j     ABCDABD
k         ABCDABD 
next -1000012
```

#### AC 自动机

#### 排序

#### Trie

<!--Note-->
###### 单词查找树（Trie）

*Trie的核心思想是空间换时间。*

- 假设字符的种数有m个，有若干个长度为n的字符串构成了一个Trie树，则每个节点的出度为m（即每个节点的可能子节点数量为m），Trie树的高度为n；
- Trie树的最坏空间复杂度为 *O(mⁿ)*；
- Trie树的最坏时间复杂度为 *O(n)*。

```
public class TrieST<Value> implements UnorderST<String, Value> { //String替代泛型Key
    private static int R = 256;
    private Node root;

    private static class Node{
        private Object val; //内部静态类无法引用外部类中Value
        private Node[] next = new Node[R]; //但可引用外部类中的静态成员
    }
}
```
<!--/Note-->

##### 查找

- 键的尾字符所对应的结点中的值非空。命中
- 键的尾字符所对应的结点中的值为空。未命中
- 查找结束于一条空链接。未命中

```
@Override
    public Value get(String key){
        Node x = get(root, key, 0);
        if (x == null)
            return null;
        return (Value) x.val;
    }
    private Node get(Node x, String key, int d){
        if (x == null)
            return null;
        if (d == key.length())
            return x;
        char c = key.charAt(d);
        return get(x.next[c], key, d+1);
    }
```

##### 插入

- 在到达键的尾字符之前就遇到了一个空链接。为键中还未被检查的每个字符创建一个对应结点并将键的值保存到最后一个字符的结点中。
- 在遇到空链接之前就到达了键的尾字符。将该结点的值设为键所对应的值。

```
@Override
    public void put(String key, Value val){
        root = put(root, key, val, 0);
    }
    private Node put(Node x, String key, Value val, int d){
        if (x == null)
            x = new Node();
        if (d == key.length()){
            x.val = val;
            return x;
        }
        char c = key.charAt(d);
        x.next[c] = put(x.next[c], key, val, d+1);
        return x;
    }
```

##### 删除

- 找到键所对应的结点并将值设为空（null）；
- 若值和链接均为空，则删去结点（返回一个空链接）。
- 若值或链接非空，不能删去结点（返回指向结点的链接）。
```
@Override
    public void delete(String key){
        root = delete(root, key, 0);
    }
    private Node delete(Node x, String key, int d){
        if (x == null)
            return null;
        if (d == key.length())
            x.val = null;
        else{
            char c = key.charAt(d);
            x.next[c] = delete(x.next[c], key, d + 1);
        }

        if (x.val != null)
            return x;
        for (char c = 0; c < R; c++){
            if (x.next[c] != null)
                return x;
        }
        return null;
    }
```

##### 大小

延时递归实现：
```
 @Override
    public int size(){
        return size(root);
    }
    private int size(Node x){
        if (x == null)
            return 0;
        int cnt = 0;
        if (x.val != null)
            cnt++;
        for (char c = 0; c < R; c++)
            cnt += size(x.next[c]);
        return cnt;
    }
```

##### 查找所有键

- keysWithPrefix()接受一个字符串参数并返回符号表中所有以该字符串作为前缀的键。

```
public Iterable<String> keys(){
        return keysWithPrefix("");
    }
    public Iterable<String> keysWithPrefix(String pre){
        Queue<String> q = new LinkedList<String>();
        collect(get(root, pre, 0), pre, q);
        return q;
    }
    private void collect(Node x, String pre, Queue<String> q){
        if (x == null)
            return ;
        if (x.val != null)
            q.add(pre);
        for (char c = 0; c < R; c++)
            collect(x.next[c], pre + c, q);
    }
```   

### 图

<!--Note-->
#### 图的定义
- **图**按照有无方向分为**无向图**和**有向图**。无向图由**顶点**和**边**构成，有向图由顶点和**弧**构成。弧有**弧尾**和**弧头**之分。

- 图按照边或弧的多少分**稀疏图**和**稠密图**。如果任意两个顶点之间都存在边叫**完全图**，有向的叫**有向完全图**。若无重复的边或顶点到自身的边则叫**简单图**。

- 图中顶点之间有**邻接点、依附**的概念。无向图顶点的边数叫做**度**，有向图顶点分为**入度**和**出度**。

- 图上的边或弧上带**权**则称为**网**。

- 图中顶点间存在**路径**，两顶点存在路径则说明是**连通**的，如果路径最终回到起始点则称为**环**，当中不重复叫**简单路径**。若任意两顶点都是连通的，则图就是**连通图**，有向则称**强连通图**。图中有子图，若子图极大连通则就是**连通分量*，有向的则称为**强连通分量**。

- 无向图中连通且 **n** 个顶点 **n-1** 条边叫**生成树**。有向图中一顶点入度为 **0**，其余顶点入度为 **1**的叫**有向树**。一个有向图由若干棵有向树构成**生成森林**。

#### 图的存储结构
- 邻接矩阵：一个二维数组存储图中的边或弧的信息。例如，`arc[0][1]`表示v0到v1的边或弧。

- 邻接表：用一个单链表数组来存储。数组下标对应图的顶点，链表中存储该顶点的所有邻接点。

- 十字邻接表：对于有向图，在邻接表的基础上添加指向入边的指针，将邻接表和逆邻接表整合。

- 邻接多重表：对于无向图，表示同一条边在邻接表中需要用两个结点，而邻接多重表只要一个结点。

- 边集数组：由两个一维数组构成。一个存储顶点信息，另一个存储边的信息。

#### 图的遍历
- **深度优先遍历**：从图中某个顶点开始，沿未被访问的邻接点出发遍历图。经过一次深度优先遍历后，若图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

- **广度优先遍历**：从图中某顶点开始，将其存入队列中。从队列中出列一个顶点，将该顶点所有未被访问的邻接点入列，重复上述操作，直至图中所有顶点都被访问到为止。
<!--/Note-->

#### 最短路径

- 求某一顶点到其余所有顶点的最短路径问题用Dijkstra算法；求所有顶点到所有顶点的最短路径问题用Floyd算法，算法更简洁。

##### Dijkstra算法

- Dijkstra算法解决了从某一顶点到其余顶点的最短路径问题，其时间复杂度为 *O(n²)*。
- 若求任意顶点到其余所有顶点的最短路径时，即对每一顶点执行一次Dijkstra算法，时间复杂度为*O(n³)*。

```

typedef int Patharc[MAXVEX]; 
typedef int ShortPathTable[MAXVEX];

void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)
{// P[v]表示v0到v最短路径的前驱顶点，D[v]表示v0到v的最短路径长度和 
	int v, w, k, min;
	int final[MAXVEX];

	for (v = 0; v < G.numVertexes; v++)
	{
		(*P)[v] = v0;
		(*D)[v] = G.arc[v0][v];
		final[v] = 0;
	}
	(*D)[v0] = 0;
	final[v0] = 1;

	for (v = 1; v < G.numVertexes; v++)
	{
		min = INFINITY;
		for (w = 0; w < G.numVertexes; w++)
		{
			if (!final[w] && (*D)[w] < min)
			{
				min = (*D)[w];
				k = w;
			}
		}
		final[k] = 1;
		for (w = 0; w < G.numVertexes; w++)
		{
			if (!final[w] && (min + G.arc[k][w] < (*D)[w]))
			{
				(*D)[w] = min + G.arc[k][w];
				(*P)[w] = k;
			}
		}
	}
}
```

##### Floyd算法

- Floyd算法解决了所有顶点到所有顶点的最短路径问题，其时间复杂度为 *O(n³)*。

```
typedef int Patharc[MAXVEX][MAXVEX];
typedef int ShortPathTable[MAXVEX][MAXVEX];

void ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)
{
	int v, w, k;
	for (v = 0; v < G.numVertexes; v++)
	{
		for (w = 0; w < G.numVertexes; w++)
		{
			(*D)[v][w] = G.arc[v][w];
			(*P)[v][w] = w;
		}
	}
	for (k = 0; k < G.numVertexes; k++)
	{
		for (v = 0; v < G.numVertexes; v++)
		{
			for (w = 0; w < G.numVertexes; w++)
			{
				if ((*D)[v][w] > (*D)[v][k] + (*D)[k][w])
				{
					(*D)[v][w] = (*D)[v][k] + (*D)[k][w];
					(*P)[v][w] = (*P)[v][k];
				}
			}
		}
	}
}
```

#### 最小生成树

- Kruskal算法主要针对边来展开，边上少时效率会非常高，所以对于稀疏图有很大的优势；Prim算法对于稠密图，即边数非常多的情况会更好一些。

##### Prim算法

- 对于n个顶点，Prim算法的时间复杂度为 *O(n²)*。

```
void MiniSpanTree_Prim(MGraph G)
{
	int min, i, j, k;
	int adjvex[MAXVEX]; // 存储生成树中与下标顶点最近的邻接点
	int lowcost[MAXVEX]; // 存储生成树到下标顶点的最小权重
	adjvex[0] = 0;
	lowcost[0] = 0;
	for (i = 1; i < G.numVertexes; i++)
	{
		adjvex[i] = 0;
		lowcost[i] = G.arc[0][i];
	}
	
	for (i = 1; i < G.numVertexes; i++)
	{
		min = INFINITY;
		k = 0;
		for (j = 1; j < G.numVertexes; j++)
		{
			if (lowcost[j] != 0 && lowcost[j] < min)
			{
				min = lowcost[j];
				k = j;
			}
		}
		printf("(%d, %d)", adjvex[k], k);
		lowcost[k] = 0;

		for (j = 1; j < G.numVertexes; j++)
		{
			if (lowcost[j] != 0 && G.arc[k][j] < lowcost[j])
			{
				adjvex[j] = k;
				lowcost[j] = G.arc[k][j];
			}
		}
	}
}
```

######  

##### Kruskal算法

- 对于e条边，Find函数的时间复杂度为 *O(loge)*，故Kruskal算法的时间复杂度为*O(eloge)*。

```

/* Kruskal算法生成最小生成树 */
void MiniSpanTree_Kruskal(MGraph G)
{
	int i, n, m;
	Edge edges[MAXEDGE];
	int parent[MAXVEX]; 
	/* 此处省略将邻接矩阵G转化为边集数组并按权从小到大排序的代码 */
	for (i = 0; i < G.numVertexes; i++)
		parent[i] = 0;

	for (i = 0; i < G.numEdges; i++)
	{
		n = Find(parent, edges[i].begin);
		m = Find(parent, edges[i].end);
		if (n != m)
		{
			printf("(%d, %d) %d ", edges[i].begin, edges[i].end, edges[i].weight);
			parent[n] = m;
		}
	}
}

int Find(int *parent, int f)
{
	while (parent[f] > 0)
		f = parent[f];
	return f;
}
```

######  

#### 拓扑排序

- 对于n个顶点e条弧的AOV网，扫描顶点表将入度为0的顶点入栈的时间复杂度为 *O(n)*, 每个顶点入栈一次，出栈一次，入度减1的操作共执行e次，所以整个算法的时间复杂度为 *O(n+e)*。

```
/******** 邻接表 *********/
struct EdgeNode
{
	int adjvex;
	int weight;
	EdgeNode *next;
};

typedef struct VertexNode
{
	int in;
	int data;
	EdgeNode *firstedge;
}AdjList[MAXVEX];

typedef struct
{
	AdjList adjList;
	int numVertexes, numEdges;
}graphAdjList, *GraphAdjList;
```

```
/* 拓扑排序，若GL无回路返回0，若有回路返回-1 */
int TopologicalSort(GraphAdjList GL)
{
	EdgeNode *e;
	int i, k, gettop;
	int top = -1;
	int count = 0;
	int *stack;
	stack = (int *)malloc(GL->numVertexes * sizeof(int));
	for (i = 0; i < GL->numVertexes; i++)
		if (GL->adjList[i].in == 0)
			stack[++top] = i;
	while (top >= 0)
	{
		gettop = stack[top--];
		printf("%d -> ", GL->adjList[gettop].data);
		count++;
		for (e = GL->adjList[gettop].firstedge; e; e = e->next)
		{
			k = e->adjvex;
			if (--GL->adjList[k].in == 0)
				stack[++top] = k;
		}
	}
	if (count < GL->numVertexes)
		return -1;
	else
		return 0;
}
```

#### 并查集

用于解决动态连通性问题，能动态连接两个点，并且判断两个点是否连通。

方法|描述
-|-
UF(int N)|以整数标识（0到N-1）初始化N个节点
void union(int p, int q)|连接p和q节点
int find(int p)|查找p（0到N-1）所在的分量的标识符
boolean connected(int p, int q)|判断p和q是否在同一个连通分量中
int count()|连通分量的数量

```

public abstract class UF {
    protected int[] id;
    protected int count;
    public UF(int N){
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }
    public abstract void union(int p, int q);
    public abstract int find(int p);
    public boolean connected(int p, int q){
        return find(p) == find(q);
    }
    public int count(){
        return count;
    }
}
```

算法|union|find   
-|-|-
quick-find算法|N|1
quick-union算法|树高|树高
加权quick-union算法|logN|logN
路径压缩的加权quick-union算法|非常接近 1	|非常接近 1

##### quick-find算法

- 可以快速进行 find 操作，也就是可以快速判断两个节点是否连通。

- 需要保证同一连通分量的所有节点的 id 值相等，就可以通过判断两个节点的 id 值是否相等从而判断其连通性。

- 但是 union 操作代价却很高，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值。

```
public class QuickFindUF {
    private int[] id;    // id[i] = component identifier of i
    private int count;   // number of components

    public QuickFindUF(int n) {
        count = n;
        id = new int[n];
        for (int i = 0; i < n; i++)
            id[i] = i;
    }

    public int find(int p) {
        return id[p];
    }

    public void union(int p, int q) {
        int pID = id[p];
        int qID = id[q];  
        if (pID == qID) return;

        for (int i = 0; i < id.length; i++)
            if (id[i] == pID) id[i] = qID;
        count--;
    }
    
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
    
    public int count() {
        return count;
    }
}
```

######  

##### quick-union算法

```
public class QuickUnionUF {
    private int[] parent;  
    private int count; 

    public QuickUnionUF(int n) {
        parent = new int[n];
        count = n;
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public int find(int p) {
        while (p != parent[p])
            p = parent[p];
        return p;
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ; 
        count--;
    }
    
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
    
    public int count() {
        return count;
    }
}

```

######  

##### 加权quick-union算法

```
public class WeightedQuickUnionUF {
    private int[] parent;  
    private int[] size;    
    private int count;    

    public WeightedQuickUnionUF(int n) {
        count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    public int find(int p) {
        while (p != parent[p])
            p = parent[p];
        return p;
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;

        // make smaller root point to larger one
        if (size[rootP] < size[rootQ]) {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        else {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        }
        count--;
    }
    
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
    
    public int count() {
        return count;
    }
}

```

######  

##### 路径压缩的加权quick-union算法

在检查节点的同时将它们直接链接到根节点，只需要在 find 中添加一个循环即可。
```
class UF {
    // 连通分量个数
    private int count;
    // 存储一棵树
    private int[] parent;
    // 记录树的“重量”
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        
        // 小树接到大树下面，较平衡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    private int find(int p) {
        while (parent[p] != p) {
            // 进行路径压缩
            parent[p] = parent[parent[p]];
            p = parent[p];
        }
        return p;
    }

    public int count() {
        return count;
    }
}
```

#### 网络流

#### 图搜索

##### 深度优先搜索

```
private void dfs(Grapth G, int v){
	maked[v] = true;
    for (int w : G.adj(v)) {
    	if (!marked[w]) {
            dfs(G, w);
        }
    }
}
```

##### 广度优先搜索

```
private void bfs(Grapth G, int s){
	Queue<Integer> q = new LinkedList<>();
    marked[s] = true;
    q.offer(s);
    while (!q.isEmpty()) {
        int v = q.poll();    
        for (int w : G.adj(v)) {
        	if (!marked[w]) {
                marked[w] = true;
                q.offer(w);
            }
        }
    }
}
```

### 其它

#### 汉诺塔

#### 哈夫曼编码

## 海量数据处理

### MapReduce

### 海量数据处理方式

#### top-k

##### 最大最小堆 O(nlogk)

##### 基于切分的快速选择 O(n)

#### 内存限制

##### 分割小文件

###### hash(x) % m

####### 重复字符划分到同一小文件中

##### 归并小文件

###### top-k

####### 每个小文件取top-k，m个top-k中再取top-k

###### 排序

####### 每个小文件排序，归并排序m个小文件

#### 统计频率

##### trie树 O(n * le)

##### HashMap

#### 判重

##### Bloom filter

允许一定错误率

##### HashSet

#### 排序

##### 快排 / 堆 / 归并 nlog(n)

## 数学与逻辑

### 概率题

#### 抢红包

#### 洗牌

#### 蓄水池抽样

#### Rand7

### 智力题

#### 二进制问题

#### 水桶问题

#### 钱问题

#### 蓝眼问题

#### 时间问题

#### 重量问题

#### 数学问题

## LeetCode

### 算法总结

#### 双指针

<!--Note-->
####### 需要对元素做对比
- 主要用于需要**遍历**数组，字符串，链表等。
- 需要对两个元素进行**对比、交换、运算**等操作。
<!--/Note-->

##### 有序数列的双指针：动态窗口

- 两个指针从两端向中间靠拢

##### 快慢指针

- 快指针走到终点时，慢指针正好走一半

#### 排序

##### Kth and TopK

- **sort()排序**：时间复杂度 O(NlogN)，空间复杂度 O(1)
- **堆**：时间复杂度 O(NlogK)，空间复杂度 O(K)。适用于海量数据。
- **快速选择**：时间复杂度 O(N)，空间复杂度 O(1)。会改变原数组。

###### 快速选择

```
public int quickSelect(int a[], int k) {
	int lo = 0, hi = a.length - 1;
	while (true) {
		int j = partition(a, lo, hi);
		if (k == j) return a[j];
		else if (k < j) hi = j - 1;
		else lo = j + 1;
	}
}

private int partition(int[] a, int lo, int hi) {
	int i = lo, j = hi + 1;
    while (true) {
    	while (i < hi && a[lo] > a[++i]);
        while (j > lo && a[lo] < a[--j]);
        if (i >= j) break;
		swap(a, i, j);
	}
	swap(a, lo, j);
	return j;
}
```

####### 时间复杂度 O(N)，空间复杂度 O(1)。会改变原数组

###### 堆

####### 时间复杂度 O(NlogK)，空间复杂度 O(K)。适用于海量数据

###### sort()排序

####### 时间复杂度 O(NlogN)，空间复杂度 O(1)

##### 出现频率排序

###### 桶排序

```
public List<Integer> frequencyBucket(int[] nums, int k) {
    Map<Integer, Integer> frequencyForNum = new HashMap<>();
    for (int num : nums) {
        frequencyForNum.put(num, frequencyForNum.getOrDefault(num, 0) + 1);
    }
    List<Integer>[] buckets = new ArrayList[nums.length + 1];
    for (int key : frequencyForNum.keySet()) {
        int frequency = frequencyForNum.get(key);
        if (buckets[frequency] == null) {
            buckets[frequency] = new ArrayList<>();
        }
        buckets[frequency].add(key);
    }
}
```

##### 荷兰国旗

###### 三向切分

```
protected void ThreeWayPartition(int[] nums, int v) {
   int lt = 0, i = 0, gt = nums.length - 1;
   while (i <= gt) {
        if (nums[i] < v) {
            swap(nums, lt++, i++);
        } else if (nums[i] > v) {
            swap(nums, i, gt--);
        } else {
            i++;
        }
    }
}
```

#### 贪心算法

<!--Note-->
####### 寻找最优解
- 必定**一次遍历**数组或字符串的过程;
- 在遍历过程中保证遍历过的**局部最优**，最后达到全局最优。

<!--/Note-->

##### 区间调度

先对数组内的区间进行排序，再贪心遍历。
```
Arrays.sort(points, new Comparator<int[]>() {
	@Override
	public int compare(int[] o1, int[] o2) {
		return o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0];
	}
});
```

```
Arrays.sort(points, (o1, o2) -> (o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0]));
```

#### 二分查找

<!--Note-->
####### 有序集合中寻找某值或边界

<!--/Note-->

##### 查找某值

```
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l <= h) { 
        int m = l + (h - l) / 2;
        if (nums[m] == key) {
            return m;
        } else if (nums[m] > key) {
            h = m - 1; 
        } else {
            l = m + 1;
        }
    }
    return -1; 
}
```
- 返回值不是 -1，而是 h 时，返回左值。例如，1 2 4 5 6，key = 3, 返回2；
- 返回值不是 -1，而是 l 时，返回右值。例如， 1 2 4 5 6，key = 3, 返回4。

##### 查找边界

找到时返回最左边的值; 找不到时返回右值。
- 循环条件为 l < h
- h 的赋值表达式为 h = m
- 最后返回 l 而不是 -1
```
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= key) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```
例如，1 2 2 2 3, key = 2, 返回最左边的2；1 2 4 5 6, key = 3, 返回4。
*PS*: 该版本取右值相较于原始版本的区别在于，`l` 无法走到 `nums.length` 的位置，若需要，则应该令` h = nums.length`;



#### 分治算法

<!--Note-->
####### 分解成子问题，子问题递归求解，合并子问题
```
public void part(int lo, int hi) {
	part(lo, i);
    part(i + 1, hi);
    merge(lo, i, hi);
}
```

<!--/Note-->

##### 归并排序

<!--Note-->
######## 数组或 N 中的每 2 个元素之间需满足某个不等式关系

```
private int[] aux = new int[a.length];

private void sort(int[] a, int l, int h) {
    if (l >= h) return;
    int m = l + (h - l) / 2;
    sort(a, l, m);
    sort(a, m + 1, h);
    merge(a, l, m, h);
}

private void merge(int[] a, int l, int m, int h) {
    int i = l, j = m + 1;
    for (int k = l; k <= h; k++) {
        aux[k] = a[k];
    }  
    for (int k = l; k <= h; k++ ){
        if (i > m) a[k] = aux[j++];
        else if (j > h) a[k] = aux[i++];
        else if (aux[i] > aux[j]) a[k] = aux[j++];
        else a[k] = aux[i++];
    }
}

```
<!--/Note-->

###### 漂亮数组

```
/* A 是漂亮数组，则 a * A + b 也是漂亮数组 
 * A 为奇数漂亮数组，B 为偶数漂亮数组，[A, B] 为漂亮数组
 * 数组两两配对，左数组 * 2 - 1 一定是奇数组，右数组 * 2 一定为偶数组，合并一定为漂亮数组
 * 假设 [1] 是最小漂亮数组，按照上面规律递推得到的一定是漂亮数组。 
 * |1|1|1|1|1|1|1|1|
 * |1 2|1 2|1 2|1 2|
 * |1 3 2 4|1 3 2 4|
 * |1 5 3 7 2 6 4 8|
 */
 
public void part(int[] a, int lo, int hi) {
    if (hi <= lo) return;
    int mid = lo + (hi - lo) / 2;
    part(a, lo, mid);
    part(a, mid + 1, hi);
    merge(a, lo, mid, hi);
}
private void merge(int[] a, int lo, int mid, int hi) {
    for (int i = lo; i <= hi; i++) {
        if (i <= mid ) a[i] = 2 * a[i] - 1;
        else a[i] = 2 * a[i];
    }
}
 
```

##### 罗列组合的分治

```

public List<T> part(int start,int end) {
	List<T> list = new ArrayList<>();
    for (int i = start; i < end; i++) {
    	// i 左部分的所有组合
    	List<T> left = part(start, i);
        // i 右部分的所有组合
        List<T> right = part(i + 1, end);
        // 左部分的每种组合
        for (T l : left) {
        	// 右部分的每种组合
        	for (T r : right) {
            	// 左右组合合并
            	list.add(merge(l, r));
            }
        }
    }
    return list;
}
```


#### 搜索

##### BFS

<!--Note-->
######## 用于寻找最短路径。
- 队列 Queue ：进行逐层遍历
- 标记数组 visited ： 标记已访问节点
- 邻接表 Adjacency ： 寻找相邻节点

```
private int bfs(List<Integer>[] Adjacency, int s, int e) {
	Queue<Integer> queue = new LinkedList<>();
    boolean[] visited = new boolean[Adjacency.length];
    
    visited[s] = true;
    queue.offer(s);
    int path = 1;
    
    while (!queue.isEmpty()) {
    	int size = queue.size();
        path++;
        // 遍历该层所有节点
        while (size-- > 0) {
            int v = queue.poll();
            // 该层每个节点的相邻节点入列作为下一层
            for (int w : Adjacency[v])) {
            	if (!visited[w]) {
                	if (w == e) {
                    	return path;
                    }
                	visited[w] = true;
                	queue.offer(w);
            	}
            }
        }
    }
    
    return 0;
}
```
<!--/Note-->

###### 双向BFS

```
private int bfs(List<Integer>[] Adjacency, int s, int e) {
	Queue<Integer> queue1 = new LinkedList<>();
    Queue<Integer> queue2 = new LinkedList<>();
    boolean[] visited1 = new boolean[Adjacency.length];
    boolean[] visited2 = new boolean[Adjacency.length];
    
    queue1.offer(s);
    queue2.offer(e);
    visited1[s] = true;
    visited2[e] = true;
    
    int path = 1;
    
    while (!queue1.isEmpty() && !queue2.isEmpty()) {
    	//保证每次都是用包含最少元素的进行扩散
        if (queue1.size() > queue2.size()) {
        	Queue<Integer> tmp = queue1;
            queue1 = queue2;
            queue2 = tmp;
            boolean[] t = visited1;
            visited1 = visited2;
            visited2 = t;
        }
    
    	int size = queue.size();
        path++;
        // 遍历该层所有节点
        while (size-- > 0) {
            int v = queue1.poll();
            // 该层每个节点的相邻节点入列作为下一层
            for (int w : Adjacency[v])) {
            	if (!visited1[w]) {
                	if (visited2[w]) {
                    	return path;
                    }
                    queue1.offer(w);
                	visited1[w] = true;	
            	}
            }
        }
    }
    
    return 0;
}
```

##### DFS

<!--Note-->
######## 用于寻找连通区域。
```
private int[][] direction = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

private void dfs(char[][] grid, int i, int j) {
    if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == '0') {
        return;
    }
    grid[i][j] = '0';
    for (int[] d : direction) {
        dfs(grid, i + d[0], j + d[1]);
    }
}
```
<!--/Note-->

###### 从边界开始查找

```
for(int i = 0; i < m; i++){
	dfs(board, i, 0，visited);
    dfs(board, i, m - 1，visited);
}
for(int j = 0 j < n; j++){
	dfs(board, 0, j，visited);
	dfs(board, n - 1, j，visited);
}
```

##### Backtracking

<!--Note-->
######## 用于寻找排列组合等多种情况的集合。
```
private void backtracking(List<List<Integer>> lists, List<Integer> list, 
	boolean[] visited, final int[] a) {
    
    if (list.size() == a.length) {
        lists.add(new ArrayList<>(list)); // 重新构造一个 List
        return;
    }
    for (int i = 0; i < visited.length; i++) {
        if (visited[i]) {
            continue;
        }
        visited[i] = true;
        list.add(a[i]);
        backtracking(lists, list, visited, a);
        list.remove(list.size() - 1);
        visited[i] = false;
    }
}
```
<!--/Note-->

###### 多个 visited 数组约束

####### 数独

```

int n = 3;
int N = n * n;
boolean[][] rows = new boolean[N][10];
boolean[][] columns = new boolean[N][10];
boolean[][][] boxes = new boolean[n][n][10];
```

####### N皇后

```

boolean[] rows = new boolean[n];
boolean[] columns = new boolean[n];
boolean[] diagonal = new boolean[2 * n - 1];
boolean[] backDiagonal = new boolean[2 * n - 1];
```

###### 排列、组合、子集

####### 含有相同元素

```
	// 排列
	for (int i = 0; i < nums.length; i++) {
        if (i != 0 && nums[i] == nums[i - 1] && !visited[i - 1]) {
            continue;  // 防止重复
        }
        if (visited[i]){
            continue;
        }
        visited[i] = true;
        list.add(nums[i]);
        backtracking(lists, list, visited, nums);
        list.remove(list.size() - 1);
        visited[i] = false;
    }
```

```
	// 组合或子集
	for (int i = start; i < nums.length; i++) {
        if (i != 0 && nums[i] == nums[i - 1] && !visited[i - 1]) {
            continue;  // 防止重复
        }
        if (visited[i]){
            continue;
        }
        visited[i] = true;
        list.add(nums[i]);
        backtracking(i + 1, lists, list, visited, nums);
        list.remove(list.size() - 1);
        visited[i] = false;
    }
```

#### 动态规划

<!--Note-->
####### 数组、字符串和 n 中的一个或两个，返回 int 或 boolean
- 寻找最优或组合数，即可用贪心或回溯
- 穷举找规律，列出转移方程。
- 状态转移方程常用格式：
```
dp[i] = dp[i - 1]; // 表达式
dp[i] = Math.max(dp[i], dp[i - 1]); // 比较大小
dp[i] = dp[i] || dp[i - 1]; // 返回boolean
```
<!--/Note-->

##### 斐波那契数列

##### 0-1背包

```
// W 为背包总体积
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j <= W; j++) {
            if (j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```
空间优化后：
```
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[] dp = new int[W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = W; j >= w; j--) {
            dp[j] = Math.max(dp[j], dp[j - w] + v);
        }
    }
    return dp[W];
}
```

###### 数组元素和为目标值

将题目转化为求数组中元素和为target的组合数，即01背包问题中，背包刚好装满的组合数。

```
public int zeroOnePack(int[] nums, int target) {
	int n = nums.length;
	int[][] dp = new int[n + 1][target + 1];
	for (int i = 1; i < n + 1; i++) {
		for (int j = 1; j < target + 1; j++) {
			if (nums[i - 1] == j) {
            	dp[i][j] = dp[i - 1][j] + 1;
            } else if (nums[i - 1] < j) {
            	dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];
            } else {
            	dp[i][j] = dp[i - 1][j];
            }
        }
	}
	return dp[n][target];
}
```

优化后：
```
public int zeroOnePack(int[] nums, int target) {
	int[] dp = new int[target + 1];
	dp[0] = 1;
	for (int num : nums) {
		for (int i = target; i >= num; i--) {
			dp[i] += dp[i - num];      
        }
	}
	return dp[target];
}
```

###### 多维背包

###### 完全背包

####### 逆序遍历改为正序

##### 两个字符串

```
public int twoStr(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = f1(dp[i - 1][j - 1]);
            } else {
                dp[i][j] = f2(dp[i][j - 1], dp[i - 1][j]);
            }
        }
    }
    return dp[m][n];
}
```

##### 两种状态dp

###### 抢 & 不抢

```
// 最大收益 = MAX（这家不抢看上家， 这家抢看上上家）
dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i])
```


树形递归dp
```
// 当前不抢 = MAX(子节点不抢, 子节点抢)
dp[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]); 
// 当前抢 = 当前金额 + 子节点不抢
dp[1] = node.val + left[0] + right[0];
return dp;
```

###### 持有 & 不持有

```
// 不持有收益 = MAX(昨天不持有今天不动， 昨天持有今天不持有)
sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);

// 持有收益 = MAX(昨天持有今天不动，昨天不持有今天持有)
buy[i] = Math.max(buy[i - 1], sell[i - 1] - prices[i]);
```

次数限制
```
buy[i][j] = Math.max(buy[i - 1][j], sell[i - 1][j - 1] - prices[i]);
```

###### up & down

##### 返回boolean

```
dp[0] = true; // 赋初始值
dp[i] = dp[i - j] || dp[i - k]; // 状态转移
```

#### 数学

##### 约瑟夫环

约瑟夫环中，每当有一个人出圈，出圈的人的下一个人成为新的环的头，相当于把数组向前移动 m 位。若已知 n-1 个人时，胜利者的下标位置位 f(n−1,m) ，则 n 个人的时候，就是往后移动 m 位，(因为有可能数组越界，超过的部分会被接到头上，所以还要模 n )，根据此推导过程得到的计算公式为：
  `f(n,m) = (f(n−1,m) + m) % n`
。

### 数据结构总结

#### 链表

##### 递归

##### 循环

#### 树

##### 递归

###### 绝大部分使用递归

##### 迭代

###### 层次遍历

####### BFS，使用 Queue 辅助遍历

###### 前中后序遍历

####### 使用 Stack 辅助实现非递归遍历

##### BST

###### 根节点 >= 左子树所有节点，<= 右子树所有节点

###### 中序遍历有序

##### Trie

```
class Trie {
	private TrieNode root;
    
    private class TrieNode {
        boolean isEnd;
        TrieNode[] next;
        TrieNode () {
            next = new TrieNode[26];
        }
    }

    public Trie() {
        root = new TrieNode();
    }
    
    ...
}
```

#### 辅助数据结构

<!--Note-->
####### *一次遍历*的过程中，利用辅助数据结构模拟某个过程
- 在 O(1) 内得到特定元素；
- 要求时间复杂度 O(n) 和 空间复杂度 O(n) 时。
<!--/Note-->

##### 栈和队列

###### 单调栈

<!--Note-->
######### 可以找到从左/右遍历第一个比它小/大的元素的位置
```
public int[] findNextGreater(int[] T) {
	if (T == null) return null;
    int[] nextGreater = new int[T.length];
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < T.length; i++) {
    	while (!stack.isEmpty() && T[i] > T[stack.peek()]) {
        	int j = stack.pop();
            nextGreater[j] = i - j;
        }
        stack.push(i);
    }
    return nextGreater;
}
```
<!--/Note-->

###### 辅助栈

<!--Note-->
######### 括号匹配、表达式求值
<!--/Note-->

##### 哈希表

- 可在 O(1) 时间复杂度内查找某个元素
- HashMap 用于映射关系或统计次数
- HashSet 用于查找元素是否存在集合中

#### 字符串

##### 循环位移

- 翻转字符串实现循环位移
- 字符串拼接后找子串判断是否循环位移

#### 数组和矩阵

##### 二分查找法

- 数组和矩阵无序时，统计出 <=mid 的元素个数, 最终定位到所求整数；
- 时间复杂度为 O(NlogN), 空间复杂度为 O(1);


##### 双指针法

- 数组元素在[0, n - 1] 或 [1, n] 之间。
- 可以将数组看似为链表求解，一般进行判环。

#### 图

##### 二分图

###### DFS 染色

###### BFS 染色

##### 拓扑排序

- 判断是否存在环；
- 时间复杂度 O(V + E)

###### BFS

```
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        int[] inDegrees = new int[numCourses]; // 入度表
        List<Integer>[] adjacency = new List[numCourses]; // 邻接表
        for (int i = 0; i < numCourses; i++) {
            adjacency[i] = new ArrayList<>();
        }
        for (int[] cp : prerequisites) {
            inDegrees[cp[0]]++;
            adjacency[cp[1]].add(cp[0]);
        }

        int[] orders = new int[numCourses];
        int j = 0;
        
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; i++) {
            if (inDegrees[i] == 0) {
                orders[j++] = i;
                queue.add(i);
            }
        }
        while (!queue.isEmpty()) {
            int pre = queue.poll();
            numCourses--;
            for (int cur : adjacency[pre]) {
                inDegrees[cur]--;
                if (inDegrees[cur] == 0) {
                    orders[j++] = cur;
                    queue.add(cur);
                }
            }
        }
        return numCourses == 0 ? orders : new int[0];
    }
}
```

###### DFS

```
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<Integer>[] adjacency = new List[numCourses]; // 邻接表
        for (int i = 0; i < numCourses; i++) {
            adjacency[i] = new ArrayList<>();
        }
        for (int[] cp : prerequisites) {
            adjacency[cp[1]].add(cp[0]);
        }
		
        int[] marked = new int[numCourses]; // 标志数组，0 表示未访问，1 表示正在访问，2 表示已访问    
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < numCourses; i++) {
            if (dfs(adjacency, marked, stack, i)) {
                return new int[0];
            }          
        }
        
        int[] orders = new int[numCourses];
        for (int i = 0; i < numCourses; ++i) {
            orders[i] = stack.pop();
        }
        return orders;
    }
    
    // 判定是否有环
    private boolean dfs(List<Integer>[] adjacency, int[] marked, Deque<Integer> stack, int pre) {
        if (marked[pre] == 1) return true;
        if (marked[pre] == 2) return false;
        marked[pre] = 1;
        for (int cur : adjacency[pre]) {
            if (dfs(adjacency, marked, stack, cur)) {
                return true;
            }
        }
        marked[pre] = 2;
        stack.push(pre);
        return false;
    }
}
```

##### 并查集

###### quick-union算法

```
public class QuickUnionUF {
    private int[] parent;  
    private int count; 

    public QuickUnionUF(int n) {
        parent = new int[n];
        count = n;
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }

    public int find(int p) {
        while (p != parent[p])
            p = parent[p];
        return p;
    }

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ) return;
        parent[rootP] = rootQ; 
        count--;
    }
    
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
    
    public int count() {
        return count;
    }
}

```

#######  

#### 位运算

##### 技巧

###### x ^ 1s = ~x，可将一个数的位级表示翻转

###### x ^ x = 0，可去除一组数中两两重复的数

###### n & (n - 1)， 可去除 n 中最低位的 1

```

01011011 &
01011010
--------
01011010
```

###### n & (-n)，可得到 n 中最低位的 1

```

10110100 &
01001100
--------
00000100

```
