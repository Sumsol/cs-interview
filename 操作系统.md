# 操作系统

<!--Note-->
## 资料

- 《现代操作系统》
- 《深入理解计算机系统》
- 《UNIX 环境高级编程》
- 《Unix/Linux 编程实践教程》
- 《鸟哥的 Linux 私房菜》
- 《The Linux Command Line》
<!--/Note-->

## 基础

### 进程管理

#### 进程与线程

##### 进程

进程是资源分配的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

##### 线程

**线程**：进程由资源平台和线程组成。线程是进程在资源平台上的一条执行流程。

**线程的优点**：
- 一个进程中可以同时存在多个线程；
- 各个线程之间可以并发地执行；
- 各个线程之间可以共享地址空间和文件等资源。

**线程的缺点**：
- 一个线程崩溃，会导致其所属进程的所有线程崩溃。

##### 线程与进程的比较

- 进程是资源分配单位，线程是CPU调度单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销：
	- 线程的创建时间比进程短；
    - 线程的终止时间比进程短；
    - 同一进程内的线程切换时间比进程短；
    - 由于同一进程的个线程间共享内存和文件资源，可直接进行不通过内核的通信。

#### 进程状态

##### 就绪状态（ready）

###### 缺少CPU时间，不占用资源

##### 运行状态（running）

###### 同时拥有CPU时间和资源

##### 阻塞状态（waiting）

###### 缺少资源，不占用CPU时间

#### 进程调度算法

##### 批处理系统

批处理系统用来处理周期性的作业，没有太多的用户操作。

批处理系统调度算法的目标：
- 吞吐量——每小时最大作业数
- 周转时间——从提交到终止间的最小时间
- CPU利用率——保持CPU始终忙碌



###### 先来先服务first-come first-served(FCFS)

最简单的非抢占式调度算法，进程按照它们请求CPU的顺序使用CPU。如果进程在执行中被阻塞，就绪队列中的第一个会得到CPU。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

###### 最短作业优先shortest job first(SJF)

适用于运行时间可预知的非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

#######  

###### 最短剩余时间优先shortest remaining time next(SRTN)

最短作业优先的抢占式版本。调度程序总是选择剩余运行时间最短的那个进程运行。

##### 交互式系统

交互式系统有大量的用户交互操作，而且抢占是必须的。

交互式系统调度算法的目标：
- 响应时间——快速响应请求
- 均衡性——满足用户的期望

###### 轮转调度

将所有就绪进程按 FCFS 的原则排成一个队列，每个进程被分配一个时间片。当队首进程时间片用完时，将它移至就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转调度的效率和时间片的大小有很大关系：
- 时间片设得太短会导致过多的进程切换，降低CPU效率；
- 而设得太长又可能引起对短的交互请求的响应时间变长。
- 将时间片设为20~50ms通常是一个比较合理的折中。

#######  

###### 优先级调度

每个进程被赋予一个优先级，允许优先级最高的可执行程序先执行。

- 为了防止高优先级进程无休止地运行下去，调度程序可能在每个时钟中断降低当前进程的优先级。
- 优先级可以是静态赋予或动态赋予。
- 可以将一组进程按优先级分为若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。

#######  

###### 多级队列

属于最高优先级类的进程运行1个时间片，属于次高优先级类的进程运行2个时间片，再次一级运行4个时间片，以此类推。当一个进程用完分配的时间片后，它被移动下一类。那么一个进程被分配的时间片依次是1、2、4、8、16...

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

#######  

##### 实时系统中的调度

实时系统要求一个请求在一个确定时间内得到响应。

实时系统调度算法的目标：
- 满足截止时间——避免丢失数据
- 可预测性——在多媒体系统中避免品质降低

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

#### 线程实现方式

##### 用户线程

<!--Note-->
######## 在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度。
- 由于用户线程的维护由相应进程来完成（通过线程库函数），**不需要操作系统内核了解用户线程的存在**，可用于不支持线程技术的多进程操作系统。
- **每个进程都有自己私有的线程控制块（TCB）列表**，用来跟踪记录它各个线程的状态信息（PC、栈指针、寄存器），TCB由线程库函数来维护。
- **用户线程的切换也是由线程库函数来完成的**，无需用户态/内核态切换，所以**速度特别快**。
- **允许每个进程都有自定义的线程调度算法**。

######## 用户线程的缺点：
- 如果一个线程发起系统调用而阻塞，则整个进程在等待。
- 运行中的线程只有主动地交出CPU的使用权后才运行进程中的其他线程。
- 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。
<!--/Note-->

######  

##### 内核线程

<!--Note-->
######## 是指在操作系统中的内核当中实现的一种线程机制，有操作系统的内核来完成线程的创建、终止和管理。
- 在支持内核线程的操作系统中，**由内核来维护进程和线程的上下文信息（PCB和TCB）**；
- **线程的创建、终止和切换都是通过系统调用/内核函数的方式来进行**，由内核来完成，因此系统**开销较大**；
- 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；
- **时间片分配给线程**，多线程的进程获得更多CPU时间。
<!--/Note-->

######  

#### 协程

##### 轻量级线程

###### 内核支持的用户线程。

###### 每个轻量级线程由一个单独的内核线程来支持。

###### 用户控制调度的内核线程。

#### 进程同步

##### 竞争条件

两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精准时序，称为竞争条件（race condition）。


##### 临界区

对共享内存进行访问的程序片段称为临界区（cirtical section）。

两个进程不同时处于临界区，就能够避免竞争条件。

共享数据并发进程正确高效地进行协作的条件：
	1）任何两个进程不能同时处于其临界区。
    2）不应对CPU速度和数量做任何假设。
    3）临界区外运行的进程不得阻塞其他进程。
    4）不得使进程无限期等待进入临界区。

##### 实现方法

###### 互斥方法

####### 屏蔽中断

使每个进程进入临界区后屏蔽所有中断，在要离开之前再打开中断。

屏蔽中断适用于操作系统本身，而不适用于用户进程。

####### 软件方法

######## 严格轮换法

连续测试一个变量直到某个值出现为止，称为**忙等待**。该方式浪费CPU时间，应该避免。

用于忙等待的锁，称为**自旋锁**。

#########  

turn值为0，允许进程0进入临界区，进程0离开临界区时，turn值设为1，允许进程1进入临界区，进程1离开临界区时，turn值设为0.

######## Peterson算法

```
while(TRUE){
	flag[i] = TRUE;
    turn = j;
    while (flag[j] && turn == j);
    	
        CRITICAL SECTION
        
    flag[i] = FALSE;
    
    	REMAINDER SECTION
        
}
```

####### 原子操作

原子操作是指一组相关的操作要么都不间断地执行，要么都不执行。

######## TLS(test and set lock)

```
boolean TestAndSet(boolean *target){
	boolean rv = *target;
    *target = TRUE;
    return rv;
}

class Lock{
	int value = 0;
}

Lock::Acquire(){
	while(TestAndSet(value);
}

Lock::Release(){
	value = 0;
}
```

######## XCHG(exchange)

```
void Exchange(boolean *a, boolean *b)
{
	boolean temp = *a;
    *a = *b;
    *b = temp;
}

class Lock{
	int lock = 0;
    int key = 1;
}

Lock::Acquire(){
	key = 1;
	while(key == 1)
    	Exchange(lock, key);
}

Lock::Release(){
	lock = 0;
}
```



###### 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作均是不可分割的原子操作，在执行这些操作时屏蔽中断。

####### 使用信号量解决生产者-消费者问题

生产值-消费者（有界缓冲区）问题：两个进程共享一个固定大小的缓冲区。生产者将信息放入缓冲区，消费者从缓冲区取出信息。缓冲区属于临界资源。

```
private LinkedList<Object> list = new LinkedList<Object>();
private static final int N = 10;
// 互斥量
private final Semaphore mutex = new Semaphore(1);
// 空位
private final Semaphore empty = new Semaphore(N);
// 满位
private final Semaphore full = new Semaphore(0);

public void producer() {
    while(true) {
    	empty.acquire();
        mutex.acquire();
        list.add(new Object());
        mutex.release();
        full.release();
        
        Thread.sleep(1000);
    }
}

public void consumer() {
    while(true) {
    	full.acquire();
        mutex.acquire();
        list.remove();
        mutex.release();
        empty.release();
        
        Thread.sleep(1000);
    }
}
```

###### 管程（monitor）

管程（monitor）是由过程、变量及数据结构等组成的一个集合。

在任一时刻管程中只能有一个活跃进程。

进入管程时的互斥由编译器负责，出错的可能性更小。

```
monitor example
	integer i;
    condition c;
    
    procedure insert();
    ...
    end;
    
    procedure consumer();
    ...
    end;
end monitor;
```




####### 条件变量

管程提供互斥，但还需要引入**条件变量**使得进程无法继续运行时被阻塞。相关的两个操作：wait和signal。对条件变量执行wait操作会导致进程调用阻塞，可令其他进程调用管程。signal操作用于唤醒被阻塞的进程。

```
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

#### 经典进程同步问题

##### 哲学家进餐问题

错误解法1————无法拿起叉子时阻塞：如果5位哲学家同时拿起左叉，则都拿不到右叉，发生死锁。
错误解法2————无法拿起叉子时思考一段时间后再尝试：如果同时拿起左叉，则都拿不到右叉，都等待相同时间后再尝试，如此重复下去，产生饥饿。

```
#define N 5

void philosopher(int i)
{
	while (TRUE){
    	think();
        take_fork(i);
        take_fork((i+1) % N);
        eat();
        put_fork(i);
        put_fork((i+1) % N);
    }
}
```

- 使用一个二元信号量对调用think之后的语句进行保护，可防止死锁和产生饥饿。
- 使用一个state数组跟踪每个哲学家是进餐、思考还是饥饿状态，可获得最大的并行度。

```

#define N 5
#define LEFT (i+N-1) % N // 左邻居
#define RIGHT (i+1) % N // 右邻居
#define THINKING 0
#define HUNGRY 1
#define EATING 2
typedef int semaphore;
int state[N];
semaphore mutex = 1;
semaphore s[N];

void philosopher(int i)
{
	while(TRUE){
    	think();
        take_forks(i);
        eat();
        put_forks(i);
    }
}

void take_forks(int i)
{
	down(&mutex);
    state[i] = HUNGRY;
    test(i);
    up(&mutex);
    down(&s[i]);
}

void put_forks(i)
{
	down(&mutex);
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&mutex);
}

void test(i)
{
	if(state[i] == HUNGRY && state[LEFT] != EATING 
    && state{RIGHT] != EATING){
    	state[i] = EATING;
        up(&s[i]);
    }
}
```

##### 读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

```
typedef int semaphore;
semaphore mutex = 1; // 控制对rc的访问
semaphore db = 1; // 控制对数据库的访问
int rc = 0; // 正在读或者即将读的进程数目

void reader(void)
{
	while (TRUE) {
    	down(&mutex);
        rc = rc + 1;
        if (rc == 1) down(&db); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&mutex);
        read_data_base();
        down(&mutex);
        rc = rc - 1;
        if (rc == 0) up(&db);
        up(&mutex);
        use_data_read();
    }
}

void writer(void)
{
	while (TRUE) {
    	think_up_data();
        down(&db);
        write_data_base();
        up(&db);
    }
}
```

#### 进程间通信IPC

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

### 通讯方式总结

1.管道：速度慢，容量有限，只有父子进程能通讯    

2.FIFO：任何进程间都能通讯，但速度慢    

3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    

4.信号量：不能传递复杂消息，只能用来同步    

5.共享内存区：能够很容易控制容量，速度快，但要保持同步
————————————————
https://blog.csdn.net/wh_sjc/article/details/70283843



##### 管道

管道，通常指无名管道。


### 1.特点：
- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用；
- 是一种特殊文件，只存在于内存中。


### 2.原型
```
#include <unistd.h>
int pipe(int fd[2]);    // 返回值：若成功返回0，失败返回-1
```
通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

###### 图

#######  

###### 半双工

###### 存于内存

###### 父子进程

##### FIFO

FIFO，也称为命名管道，它是一种文件类型。

### 1.特点
- 可用于无关进程交换数据，与无名管道不同。

- 以一种特殊设备文件存在于文件系统中。

### 2.原型

```
#include <sys/stat.h>
// 返回值：成功返回0，出错返回-1
int mkfifo(const char *pathname, mode_t mode);
```

FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。常用于客户-服务器应用程序中。


###### 图

#######  

###### 无关进程

###### 存于文件系统

##### 消息队列

消息队列，是消息的链接表，存放在内核中。

### 特点
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法

- 消息队列独立于读写进程。进程终止时，消息队列及其内容不会被删除。

- 消息队列可实现消息随机查询，可按消息类型读取，不像FIFO以先进先出次序读取。


###### 存于内核

###### 独立于读写进程

###### 异步

###### 消息随机查询

##### 信号量

信号量（semaphore）是一个计数器，用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

### 特点
- 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。

- 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。

- 每次对信号量的 PV 操作不仅限于加 1 或减 1，可加减任意正整数。

- 支持信号量组。

###### 用于互斥同步

##### 共享内存

共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。
### 特点
- 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。

- 因为多个进程可以同时操作，所以需要进行同步。

- 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

###### 最快IPC

###### 需要信号量协作同步

##### socket套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

### 死锁

- 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。

#### 必要条件

发生死锁的4个必要条件：
- 1）**互斥条件**。每个资源要么已经分配给一个进程，要么就是可用的。
- 2）**占有和等待条件**。已经得到某个资源的进程可以在请求新的资源。
- 3）**不可抢占条件**。已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 4）**环路等待条件**。死锁发生时，系统中一定有两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。

#####  

#### 处理死锁的方法

四种处理的策略：
- 1）忽略该问题。也许如果你忽略它，它也会忽略你。
- 2）检测死锁并恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。
- 3）仔细对资源进行分配，动态地避免死锁。
- 4）通过破坏引起死锁的四个必要条件之一，防止死锁的产生。

##### 鸵鸟算法

鸵鸟算法：把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

##### 死锁检测和死锁恢复

系统不试图阻止死锁的产生，而是允许死锁发生，当检测到死锁发生后，采取措施进行恢复。





###### 每种类型一个资源的死锁检测

<!--Note-->
######### 每种类型一个资源的死锁检测
可以对系统构造一张资源分配图，如果图中包含环，则存在死锁。

通过算法来检测有向图中是否存在环，从而检测死锁。

算法依次从每个节点出发进行深度优先搜索，如果碰到已经遇到的节点，那么就算找到了一个环。
<!--/Note-->

###### 每种类型多个资源的死锁检测

<!--Note-->
######### 每种类型多个资源的死锁检测
E 现有资源向量：每种已存在的资源总数。
A 可用资源向量：当前可供使用的资源数。
C 当前分配矩阵：每个进程当前所持有的每一种类型资源的资源数。
R 请求矩阵：每个进程所需要的每种类型资源的数量。

每个进程起初都不被标记，开始后会对能够被执行的算法进行标记。当算法结束时，任何没有被标记的进程都是死锁进程。

死锁检测算法如下：
- 1）寻找一个没有标记的进程 Pᵢ，R 矩阵的第 i 行向量小于等于 A。
- 2）如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转到第 1）步。
- 3）如果没有这样的进程，算法终止。

如图，进程 Pᵢ 和 P₂ 所请求的资源都得不到满足，只有进程 P₃ 可以，让 P₃ 执行，之后释放 P₃ 拥有的资源，此时 A = (2 2 2 0)。P₂ 可以执行，执行后释放 P₂ 拥有的资源，A = (4 2 2 1) 。Pᵢ 也可以执行。所有进程都可以顺利执行，没有死锁。
<!--/Note-->

###### 从死锁中恢复

<!--Note-->
######### 1.利用抢占恢复
临时将某个资源从一个进程强行取走给另一个进程使用，接着又送回。

######### 2.利用回滚恢复
周期性对进程进行检查点检查（即进程状态写入一个文件），一旦检测到死锁，恢复到较早的一个检查点。

######### 3.通过杀死进程恢复
最直接也是最简单的解决死锁的方法是杀死一个或若干个进程。
<!--/Note-->

##### 死锁避免

系统必须能判断分配资源是否安全，并且只能在保证安全的条件下分配资源。


###### 资源轨迹图 

阴影部分为 AB 两进程同时拥有打印机或绘图仪，则由互斥规则表示该区域无法进入。虚线表示进程的执行状态，运动方向只能是向上或向右。因此，如果系统一旦进入有I1、I2和I5、I6组成的矩形区域，则会进入死胡同，从而产生死锁。

###### 安全状态和不安全状态

如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每个进程进行完毕，则称该状态是安全的。

如图，依照B->C->A的次序运行进程能避免死锁，故状态是安全的。

不安全状态并不是死锁。从安全状态出发，系统能够保证所有进程都能完成，从不安全状态出发，就无法保证。

###### 单个银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，判断对请求的满足是否会导致进入不安全状态。如果是，就拒绝请求；否则，就给予分配。

###### 多个银行家算法

左边的矩阵显示了5个进程分别已分配的个各种资源数;右边的矩阵显示了使各进程完成运行所需的各资源数;最右边三个向量分别表示现有资源E、已分配资源P和可用资源A。

检查状态是否安全的算法如下：
- 1）查找右边矩阵是否有一行小于或等于A。若不存在，则系统将会死锁。
- 2）若找到这样一行，将该进程标记为终止，并将其资源加到向量A上。
- 3）重复以上两步，直到所有进程都标记为终止，其初始状态是安全的；否则，就会发生死锁。



##### 死锁预防

如果能保证四个必要条件中至少有一个不成立，那么死锁将不会产生。

###### 破坏互斥条件

如果资源不被一个进程所独占，那么死锁肯定不会发生。

例如假脱机打印机（spooling printer）技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程，由于守护进程不会请求别的资源，所以不会因打印机而产生死锁。

###### 破坏占有并等待条件

只要禁止已持有资源的进程再等待其他资源便可消除死锁。

一种实现方法是规定所有进程在执行前请求所需的全部资源。

另一种方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源。

###### 破坏不可抢占条件

只要当一个进程申请一个资源，然而却申请不到的时候，必须释放已经申请到的所有资源。

###### 破坏环路等待条件

消除环路的几种方法：
- 保证每个进程在任何时刻只能占用一个资源，如果请求另一个资源，它必须先释放第一个资源。
- 进程所有请求必须按照资源编号的顺序提出。
- 要求不允许进程请求比当前所占有资源编号低的资源。

### 内存管理

内存模型：
- 内核内存：提供给程序调度、内存分配、连接硬件资源等程序逻辑使用。
- 用户内存：各个进程使用的主要空间。

#### 虚拟内存

**虚拟内存的目的**：是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

**虚拟内存的基本思想是**：每个程序拥有自己的地址空间，这个空间被分割成多个块，每个块称作一页或页面（page）。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行 程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。

##### 分页系统地址映射

由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。

在使用虚拟内存的情况下，虚拟地址被送到内存管理单元（Memory Management Unit, MMU）,MMU把虚拟地址映射为物理内存地址。

虚拟地址空间按照固定大小划分成被称为页面（page）的若干单元。在物理内存中对应的单元称为页框（page frame）。

若程序访问一个未映射的页面，会使CPU陷入到操作系统，这个陷阱称为缺页中断或缺页错误。

######  

######  

输入的16位虚拟地址被分为4位的页号和12位的偏移量。4位的页号可以表示16个页面，12位的偏移可以为一页内的全部4096个字节编址。

可用页号作为页表的索引，以得出对应该虚拟页面的页框号。

#### 页面置换算法

PS:特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。

当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

## 页面置换算法小结
算 法 |注 释
------|------
最优算法 | 不可实现，但可用作基准
NRU（最近未使用）算法 | LRU的很粗糙的近似
FIFO（先进先出）算法 | 可能抛弃重要页面
第二次机会算法 | 比FIFO有较大的改善
时钟算法 | 现实的
LRU (最近最少使用）算法 | 很优秀，但很难实现
NFU (最不经常使用）箕法 | LRU的相对粗略的近似
老化算法 | 非常近似LRU的有效算法
工作集算法 | 实现起来开销很大
工作集时钟算法 | 好的有效算法

##### 最优（OPT, Optimal replacement algorithm）

标记每个页面被访问前所要执行的指令数，最优页面置换算法规定应该置换标记最大的页面。

该算法无法实现，是一种理论上的算法，因为操作系统无法知道各个页面下一次将在什么时候被访问。

可以通过仿真程序运行时收集的信息实现最优页面置换算法，以用来与其他可实现算法的性能进行比较。

##### 最近未使用（NUR, Not Recently Used）

每个页面都有两个状态位：R 与 M，当页面被访问时设置 R 位，当页面被修改时设置 M 位。其中 R 位会定时被清零。可以将页面分成以下四类：

- 第0类：没有被访问，没有被修改。
- 第1类：没有被访问，已被修改。
- 第2类：已被访问，没有被修改。
- 第3类：已被访问，已被修改。

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的页面（R=0，M=1），而不是被频繁使用的“干净”页面（R=1，M=0）。

NRU 的主要优点是易于理解和能够有效地被实现，虽然性能不是最好的，但是够用。

##### 先进先出（FIFO, First-In First-Out）

由操作系统维护一个当前在内存中的所有页面的链表，最新进入的页面在尾部，最早进入的放在表头，每当发生缺页中断，就替换掉表头的页面并且把新调入的页面加入到链表末尾。

该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

##### 第二次机会（second chance）

针对FIFO算法可能将经常使用的页面置换出去，因此检查最老页面的R位。若R=0，立刻置换掉；若R=1，将R位清0并将该页面放到链表尾部。

######  

##### 时钟（clock）

第二次算法经常在链表中移动页面，降低了效率。时钟算法把所有页面都保存在一个类似钟面的环形链表中，一个表针指向最老页面。

######  

##### 最近最少使用（LRU, Least Recently Used）

在缺页中断发生时，置换未使用时间最长的页面，称为LRU。

LRU是可实现的，需要在内存中维护一个所有页面的链表，最近最多使用的放表头，最近最少使用的放表尾，每次访问内存时都需更新链表，代价较大。

很少有计算机能使用硬件实现LRU算法，因此需要能用软件实现的方法。NFU（Not Frequently Used，最不常用）算法将每个页面与一个软件计数器相关联，每次时钟中断时，扫描每个页面的R位并加到其计数器上，从而跟踪各个页面被访问的频率。

NFU存在的问题是很久之前的一次使用，与最近的使用权重相等。老化（aging）算法对其进行了改进：在R位加进之前将计数器右移一位，然后加到计数器的最左端的位。老化算法的计数器只能有限位数，因此限制了对以往页面的记录。

######  

##### 工作集算法（WSClock）

简单来说，工作集就是在最近k次内存访问所使用过的页面的集合。原始的工作集算法同样代价很大，对它进行简化：在过去Nms的内存访问中所用到的页面的集合。

所以，在实现的时候，可以给每个页面一个计时器。需要置换页面时，同实际时间进行对比，R为1，更新到现在时间；R为0，在规定阈值之外的页面可以被置换。

同样，这个算法也可以用时钟的思想进行改进。

#### 分页与分段

##### 分段

分页存储管理：虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

一维的地址空间中，一个编译器在编译过程中会建立许多表，包括源程序正文、符号表、常量表、语法分析数、调用堆栈。前4个表随着编译的进行会不断地增长，使得地址空间中的块可能被装满，导致覆盖问题的出现。分段存储管理的方法可解决以上问题。

分段存储管理：每个段是一个独立的地址空间，段的长度可以是0到允许的任意值，可动态改变。不同的段长度可以不同。

- 若每个过程都位于独立的段中，那么把单独编译好的过程连接起来的操作会极大简化。
- 分段有助于几个进程之间共享过程和数据。将共享库放在一个独立的段中由各个进程共享。
- 每个段都是为程序员所知的逻辑实体，故不同的段可以有不同种类的保护。

######  

######  

##### 段页式

段页式存储管理：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

##### 分页与分段的比较

考查点|分页|分段
-----|----|----
需要程序员了解正在使用这种技术吗？|否|是
存在多少线性地址空间？|1|许多
整个地址空间可以超出物理存储器的大小吗？|是|是
过程和数据可以被区分并分别被保护吗？|否|是
其大小浮动的表可以很容易提供吗？|否|是
用间过程的共享方便吗？|否|是
为什么发明这种技术？|为了得到大的线性地址空间而不必购买更大的物理存储器|为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护

### 设备管理

#### 磁盘结构

- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。
- 柱面（Cylinder）：各个盘面上半径相同的磁道组成了一个圆柱面，称为磁盘的柱面 。柱面的个数与盘面上的磁道数相等。 

#### 磁盘调度算法

读写磁盘块所需时间的决定因素：

- 1）寻道时间（将磁盘臂移动到适当的柱面上所需的时间）。
- 2）旋转延迟（等待适当扇区旋转到磁头下所需的时间）。
- 3）实际数据传输时间。

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

##### 先来先服务（First-Come, First-Served, FCFS）

定义：磁盘驱动程序每次接受一个请求并按照接受顺序完成请求。

优点是简单和公平。缺点是很难优化寻道时间，磁头移动的距离和平均距离可能很大。

##### 最短寻道优先（Shortest Seek First，SSF）

定义：下一次总是处理与磁头距离最近的请求以使寻道时间最小化。

虽然得到最小响应时间，但缺乏公平性。当磁盘负载很重时，可能会使磁头一直停留在磁盘某区域，远离该区域的请求很难得到响应，直至该区域无请求为止。

##### 电梯算法（SCAN）

定义：与电梯运行一样，保持按一个方向移动，直到那个方向上没有请求为止，然后才改变方向。

电梯算法的一个优点是，对任意一组请求，磁盘臂移动总次数上界均为柱面数的两倍。

##### 循环扫描算法（SCAN）

定义：总是按一个方向扫描，当处理完请求的最高编号柱面后，立即回到未完成请求的最低编号柱面，然后继续沿该方向移动。

该方法相对于电梯算法在响应时间上具有更小的变异。

### 静态链接与动态链接

链接（linking）是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件能被加载到内存并执行。

#### 编译器驱动程序

Unix系统上，从源文件到目标文件的转化由编译器驱动程序完成：
`linux> gcc -o hello hello.c`
    
执行编译过程的预处理器、编译器、汇编器和链接器构成了编译系统。

- 预处理阶段：预处理器（cpp）处理#开头的命令，生成hello.i文件。
- 编译阶段：编译器（ccl）将hello.i翻译成hello.s汇编文件。
- 汇编阶段：汇编器（as）将hello.s翻译成机器语言指令，存于可重定向目标文件hello.o中。
- 链接阶段：链接器将hello.o和标准C库中的printf.o合并，生成可执行目标文件hello。

#### 静态链接

静态链接器（static linker）以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的，可以加载和运行的可执行目标文件作为输出。

链接器完成两个主要任务：
- 符号解析：每个符号对应一个函数、全局变量或静态变量。符号解析的目的是将每个符号引用和一个符号的定义关联起来。
- 重定位：链接器把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

#### 目标文件

- 可重定位目标文件：可在编译时与其他可重定位目标文件合并，创建一个可执行目标文件。
- 可执行目标文件：可被直接复制到内存并执行。
- 共享目标文件：可在加载或者运行时被动态地加载进内存并链接。

#### 动态链接

静态链接的缺点：
- 和软件一样需要定期维护和更新。
- 一些标准库中的函数几乎存在于每个程序中，多进程运行时需要分别复制一遍到内存中，是对内存的极大浪费。

共享库（shared library）是一个目标模块，在运行和加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程叫动态链接（dynamic linking），由动态链接器（dynamic linker）执行。

共享库在Linux中用.so后缀表示，在Windows中称为DLL（动态链接库）。

共享库以两种方式来“共享”：
- 在任何给定的文件系统中，一个库只有一个.so文件。所有引用该库的可执行文件共享这个.so文件中的代码和数据，不像静态库那样将内容复制和嵌入到可执行文件中。
- 在内存中，一个共享库的.text节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

## Linux

### 文件系统

- 从文件系统的角度分析数据恢复原理

#### inode

`ls -i`查看inode编号

##### 记录文件属性和block编号，一个文件占一个inode

`ls -l`查看的属性

#### block

##### 记录文件内容，一个文件会占多个block

#### 目录

##### 一个inode与至少一个block

##### block记录目录下文件的inode编号和文件名

##### 文件的 inode 本身不记录文件名

#### 文件读取

##### 根据inode查找block，再从block中读数据

### 硬链接与软链接

`ln [-sf] source_filename dist_filename`
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件

#### 硬链接（实体链接）

##### 与源文件相同inode, 不同文件名

##### 删除后，文件只要引用数不为0仍存在

##### 不能跨越文件系统

##### 不能对目录链接

#### 软链接（符号链接）

##### 不同inode，保存源文件所在绝对路径

##### 源文件删除后，链接打不开

##### 可对目录链接

##### 类似Windows的快捷方式

### 常用命令

- 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。

#### Linux缓冲机制

##### buffers和cached

`free`命令查看


###### buffers(缓冲)是即将被写入磁盘的数据

####### 减少磁盘碎片和寻道

###### cached(缓存)是从磁盘中读出的数据

####### 减少磁盘I/O，提高效率

### 僵尸进程与孤儿进程

- 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。

#### SIGCHLD信号

##### 子进程状态改变时会发送给父进程

##### 包含子进程的信息

#### wait()和waitpid()

##### 接收SIGCHLD信号，销毁子进程并返回

##### 父进程调用阻塞，waitpid()可设为非阻塞

#### 孤儿进程

##### 父进程退出，子进程还在运行

##### 会被init进程收养并释放，对系统无害

#### 僵尸进程

##### 子进程退出，父进程没调用wait(), 子进程描述符仍存在

##### 会导致系统不产生新进程

##### 杀死父进程，使其变孤儿进程
