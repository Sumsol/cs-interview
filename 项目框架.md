# 项目框架

## 面向对象

<!--Note-->
### 资料

- 《Head First 设计模式》
<!--/Note-->

### 思想

#### 三大特性

##### 封装

 例如 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。
 ```
 public class Person {

    private String name;
    private int gender;
    private int age;

    public String getName() {
        return name;
    }

    public String getGender() {
        return gender == 0 ? "man" : "woman";
    }

    public void work() {
        if (18 <= age && age <= 50) {
            System.out.println(name + " is working very hard!");
        } else {
            System.out.println(name + " can't work any more!");
        }
    }
}

 ```

###### 数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。

##### 继承

###### 实现了 IS-A 关系

###### 遵循里氏替换原则，子类对象必须能够替换所有父类对象

##### 多态

###### 编译时多态

####### 方法的重载

###### 运行时多态的三个条件

```
abstract class Animal {  
    abstract void eat();  
}  
  
 // 继承
class Cat extends Animal {  
    
    // 重写
    public void eat() {  
        System.out.println("吃鱼");  
    }  
}  

 // 继承
class Dog extends Animal {  
	
     // 重写
    public void eat() {  
        System.out.println("吃骨头");  
    }  
}

public class Test {
    public static void main(String[] args) {
      
      // 向上转型  
      Animal a = new Cat();   
      Animal b = new Dog();
      
      a.eat(); // 吃鱼
      b.eat(); // 吃骨头 
}
```

####### 继承

####### 重写

####### 向上转型

#### 设计原则

### 设计模式

#### 单例模式

手写单例模式，特别是双重检验锁以及静态内部类。

##### 定义

###### 一个实例，全局访问点

##### why

###### 只需一个实例时，可避免频繁创建对象，减少系统开销和 GC

###### 相比于全局变量，可实现需要使用时才创建对象，避免资源浪费

##### 结构

###### 私有构造函数

`private Singleton() {};`

###### 私有静态变量

`private static Singleton uniqueInstance;`

###### 公有静态函数

`public static Singleton getUniqueInstance(){}`

##### 懒汉式

###### 线程不安全

```
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}

```

####### 使用时创建

###### 线程安全

```
public static synchronized Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}
```

####### synchronized修饰方法

###### 双重校验锁

```
public class Singleton {
	private volatile static Singleton uniqueInstance;
    
    private Singleton () {
    }

	public static Singleton getUniqueInstance() {
    	if (uniqueInstance == null) {
        	synchronized(Singleton.class) {
            	if (uniqueInstance == null) {
                	uniqueInstance = new Singleton();
                }
            }
    	}
    	return uniqueInstance;
    }
}
```

####### volatile可见性和禁止指令重排序

uniqueInstance = new Singleton() 分为三步执行：
1.为 uniqueInstance 分配内存空间
2.初始化 uniqueInstance
3.将 uniqueInstance 指向分配的内存地址
但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1 > 3 > 2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。

###### 静态内部类

```
public class Singleton {
	private static class SingletonHolder {
    	private static final Singleton INSTANCE = new Singleton();
    }
    
    private Singleton () {
    }
    
    public static Singleton getUniqueInstance () {
    	return SingletonHolder.INSTANCE;
    }
}
```

####### 静态内部类被调用才加载

##### 饿汉式

###### 线程安全

```
    public class Singleton {
        // 在静态初始化器中创建单例实例，这段代码保证了线程安全
        private static Singleton uniqueInstance = new Singleton();

        private Singleton(){}
        public static Singleton getInstance(){
            return uniqueInstance;
        }
    }
```

####### 加载时创建

###### 枚举

```
public enum Singleton {
    INSTANCE;  
}
```

####### 反射和序列化都不破坏单例

##### Spring中的单例模式

###### Spring 通过 ConcurrentHashMap 实现单例注册表的特殊方式实现单例模式

```
// 通过 ConcurrentHashMap（线程安全） 实现单例注册表
private final Map<String, Object> singletonObjects = new ConcurrentHashMap<String, Object>(64);

public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
        Assert.notNull(beanName, "'beanName' must not be null");
        synchronized (this.singletonObjects) {
            // 检查缓存中是否存在实例  
            Object singletonObject = this.singletonObjects.get(beanName);
            if (singletonObject == null) {
                //...省略了很多代码
                try {
                    singletonObject = singletonFactory.getObject();
                }
                //...省略了很多代码
                // 如果实例对象在不存在，我们注册到单例注册表中。
                addSingleton(beanName, singletonObject);
            }
            return (singletonObject != NULL_OBJECT ? singletonObject : null);
        }
    }
    //将对象添加到单例注册表
    protected void addSingleton(String beanName, Object singletonObject) {
            synchronized (this.singletonObjects) {
                this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));

            }
        }
}
```

#### 工厂模式

手写工厂模式。


##### why

###### 解耦

####### 对象创建和使用分开

###### 降低代码重复

####### 某些类创建过程复杂

###### 降低维护成本

####### 直接工厂里修改

##### 简单工厂

```
public class SimpleFactory {

    public Product createProduct(int type) {
        if (type == 1) {
            return new ConcreteProduct1();
        } else if (type == 2) {
            return new ConcreteProduct2();
        }
        return new ConcreteProduct();
    }
}

```

###### 违背 (扩展)开放-(修改)封闭原则，反射可改善

######  

##### 工厂方法

```
public interface Factory {
	public Product factoryMethod();
}
```
```
public class ConcreteFactory implements Factory {
	@Override
	public Product factoryMethod() {
    	return new ConcreteProduct1();
    }   
}
```
```
public class ConcreteFactory implements Factory {
	@Override
	public Product factoryMethod() {
    	return new ConcreteProduct2();
    }   
}
```

###### 创建单一对象

######  

##### 抽象工厂

```
public interface AbstractFactory {
	public AbstractProductA createProductA();
    public AbstractProductB createProductB();
}
```
```
public class ConcreteFactory1 implements AbstractFactory {
	@Override
	public AbstractProductA createProductA() {
    	return new ProductA1();
    }   
    
    @Override
	public AbstractProductB createProductB() {
    	return new ProductB1();
    } 
}
```
```
public class ConcreteFactory2 implements AbstractFactory {
	@Override
	public AbstractProductA createProductA() {
    	return new ProductA2();
    }   
    
    @Override
	public AbstractProductB createProductB() {
    	return new ProductB2();
    } 
}
```

###### 创建对象家族

######  

##### Spring中的工厂模式

###### BeanFactory

####### 延迟注入，程序启动快

####### 仅提供最基本的依赖注入

###### ApplicationContext

####### 容器启动时一次性创建所有bean

####### 扩展了BeanFactory，还有额外功能

####### 实现类

######## ClassPathXmlApplication

######### 把上下文文件当成类路径资源。

######## FileSystemXmlApplication

######### 从文件系统中的 XML 文件载入上下文定义信息。

######## XmlWebApplicationContext

######### 从Web系统中的XML文件载入上下文定义信息。

#### 观察者模式

- 在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。
- 主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。
```
public interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObserver();
}
```
```
public class WeatherData implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private float temperature;
	
    public void setMeasurements(float temperature) {
        this.temperature = temperature;
        notifyObserver();
    }
    
    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        int i = observers.indexOf(o);
        if (i >= 0) {
            observers.remove(i);
        }
    }

    @Override
    public void notifyObserver() {
        for (Observer o : observers) {
            o.update(temperature);
        }
    }
}
```
```
public interface Observer {
    void update(float temp);
}
```
```
public class Display implements Observer {

    public Display(Subject weatherData) {
        weatherData.reisterObserver(this);
    }

    @Override
    public void update(float temp) {
        System.out.println("Display.update: " + temp);
    } 
}
``


##### Spring事件驱动模型

```
// 1.定义一个事件,继承自ApplicationEvent并且写相应的构造函数
public class DemoEvent extends ApplicationEvent{
    private static final long serialVersionUID = 1L;

    private String message;

    public DemoEvent(Object source,String message){
        super(source);
        this.message = message;
    }

    public String getMessage() {
         return message;
    }
}

// 2.定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；
@Component
public class DemoListener implements ApplicationListener<DemoEvent>{

    //使用onApplicationEvent接收消息
    @Override
    public void onApplicationEvent(DemoEvent event) {
        String msg = event.getMessage();
        System.out.println("接收到的信息是："+msg);
    }

}
// 3.发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。
@Component
public class DemoPublisher {

    @Autowired
    ApplicationContext applicationContext;

    public void publish(String message){
        //发布事件
        applicationContext.publishEvent(new DemoEvent(this, message));
    }
}

```

###### 事件角色

####### ApplicationEvent

######## ContextStartedEvent

######### ApplicationContext 启动后触发的事件

######## ContextStoppedEvent

######### ApplicationContext 停止后触发的事件

######## ContextRefreshedEvent

######### ApplicationContext 初始化或刷新完成后触发的事件

######## ContextClosedEvent

######### ApplicationContext 关闭后触发的事件

###### 事件监听者角色

####### ApplicationListener

```
package org.springframework.context;
import java.util.EventListener;

@FunctionalInterface
public interface ApplicationListener<E extends ApplicationEvent> 
	extends EventListener {
    void onApplicationEvent(E var1);
}
```

###### 事件发布者角色

####### ApplicationEventPublisher

```
@FunctionalInterface
public interface ApplicationEventPublisher {
    default void publishEvent(ApplicationEvent event) {
        this.publishEvent((Object)event);
    }

    void publishEvent(Object var1);
}

```

#####  

#### MVC

理解 MVC，结合 SpringMVC 回答。

#### 代理模式

结合 Spring 中的 AOP 回答。

##### JDK动态代理

```
public class DynamicAgent {

	//实现InvocationHandler接口，并且可以初始化被代理类的对象
    static class MyHandler implements InvocationHandler {
        private Object proxy;
        public MyHandler(Object proxy) {
            this.proxy = proxy;
        }
		//自定义invoke方法
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) 
        	throws Throwable {
            System.out.println(">>>>before invoking");
			//真正调用方法的地方
            Object ret = method.invoke(this.proxy, args);
            System.out.println(">>>>after invoking");
            return ret;
        }
    }

	//调用Proxy类的newProxyInstance方法，返回一个代理对象
    public static Object agent(Class interfaceClazz, Object proxy) {
        return Proxy.newProxyInstance(interfaceClazz.getClassLoader(), 
        	new Class[]{interfaceClazz}, new MyHandler(proxy));
    }    
}
```

```
public class ReflectTest {
    public static void main(String[] args) 
    	throws InvocationTargetException, IllegalAccessException {
		//注意一定要返回接口，不能返回实现类否则会报错
        Fruit fruit = (Fruit) DynamicAgent.agent(Fruit.class, new Apple());
        fruit.show();
    }
}
```

###### InvocationHandler接口

```
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```
- proxy：被代理的类的实例
- method：调用被代理的类的方法
- args：该方法需要的参数

###### Proxy类的newProxyInstance方法

```

public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h)
    throws IllegalArgumentException
```
loader：被代理的类的类加载器
interfaces：被代理类的接口数组
invocationHandler：InvocationHandler接口的对象实例

##### CGLIB动态代理

```
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class CGlibAgent implements MethodInterceptor {

    public Object getInstance(Object proxy) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(proxy.getClass());
        // 回调方法
        enhancer.setCallback(this);
        // 创建代理对象
        return enhancer.create();
    }
	//回调方法
    @Override
    public Object intercept(Object o, Method method, Object[] objects, 
    	MethodProxy methodProxy) throws Throwable {
        System.out.println(">>>>before invoking");
		//真正调用
        Object ret = methodProxy.invokeSuper(o, objects);
        System.out.println(">>>>after invoking");
        return ret;
    }

    public static void main(String[] args) {
        CGlibAgent cGlibAgent = new CGlibAgent();
        Apple apple = (Apple) cGlibAgent.getInstance(new Apple());
        apple.show();
    }
}
```

#####  

#### JDK 中常用的设计模式

例如装饰者模式、适配器模式、迭代器模式等。

##### 结构型

##### 创建型

##### 模板模式

```
public abstract class Template {
    //这是我们的模板方法
    public final void TemplateMethod(){
        PrimitiveOperation1();  
        PrimitiveOperation2();
        PrimitiveOperation3();
    }

    protected void  PrimitiveOperation1(){
        //当前类实现
    }

    //被子类实现的方法
    protected abstract void PrimitiveOperation2();
    protected abstract void PrimitiveOperation3();

}
public class TemplateImpl extends Template {

    @Override
    public void PrimitiveOperation2() {
        //当前类实现
    }

    @Override
    public void PrimitiveOperation3() {
        //当前类实现
    }
}
```

###### Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类

##### 桥接

###### 将抽象类中的实现部分分离

```
Abstraction abstraction = new RefinedAbstraction(new ConcreteImplementor());
```

##### 原型模式

###### 通过复制生成实例

##### 建造者模式

###### 组装复杂的实例

##### 适配器

把一个类接口转换成另一个用户需要的接口
```
public interface HDMI {
    void hdmiConnection();
}
```
```
public interface VGA {
    void vgaConnection();
}
public class MyVGA implements VGA {
    @Override
    public void vgaConnection() {
    }
}
```
```
public class Adapter implements HDMI {
    VGA vga;

    public Adapter(VGA vga) {
        this.vga = vga;
    }

    @Override
    public void hdmiConnection() {
        vga.vgaConnection();
    }
}
```
```
public class Client {
    public static void main(String[] args) {
        HDMI hdmi = new Adapter(new MyVGA());
        hdmi.hdmiConnection();
    }
}
```

###### HDMI hdmi = new Adapter(new VGA());

###### spring AOP中的适配器模式

####### AdvisorAdapter

Spring AOP 的增强或通知(Advice)使用到了适配器模式。
Spring预定义的通知要通过对应的适配器，适配成 MethodInterceptor接口(方法拦截器)类型的对象（如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice）。

###### spring MVC中的适配器模式

####### HandlerAdapter 

HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。

## Web

- [69 道 Spring 面试题和答案](http://ifeve.com/spring-interview-questions-and-answers/)
- [Spring 面试题](https://github.com/Homiss/Java-interview-questions/blob/master/%E6%A1%86%E6%9E%B6/Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98.md)
- [Spring 面试问答 Top 25](http://www.importnew.com/15851.html)
- [Spring 总结以及在面试中的一些问题.](https://www.cnblogs.com/wang-meng/p/5701982.html)


### Spring Core

#### Spring IOC

##### 控制反转（IoC）

###### 一种面向对象编程的设计思想

###### 借助“第三方”实现对象之间依赖关系的解耦

甲乙双方不相互依赖，交易活动的进行不依赖于甲乙任何一方，整个活动的进行由第三方负责管理。

##### 依赖注入（DI）

###### 实现控制反转的一种设计模式，将一个对象作为参数传入到另一个对象中去。

甲方开放接口，在它需要的时候，能够将乙方传递进来(注入)

##### IoC容器，是实现依赖注入的关键，本质上是一个工厂

交易双方之外的第三方，提供可靠性可依赖可灵活变更交易方的资源管理中心。

#### Spring AOP

AOP是一种编程思想，是对OOP的补充。
```
@Component
@Aspect
public class Aspect {

    // 定义切点  execution(返回值 包.类.方法(参数))
    @Pointcut("execution(* com.nowcoder.community.service.*.*(..))")
    public void pointcut() {

    }

    @Before("pointcut()")
    public void before() {
        System.out.println("before");
    }

    @After("pointcut()")
    public void after() {
        System.out.println("after");
    }

    @AfterReturning("pointcut()")
    public void afterReturning() {
        System.out.println("afterReturning");
    }

    @AfterThrowing("pointcut()")
    public void afterThrowing() {
        System.out.println("afterThrowing");
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("around before");
        Object obj = joinPoint.proceed();
        System.out.println("around after");
        return obj;
    }
}
```

##### AOP术语

###### Aspect（切面）

####### 一个类，定义了Pointcut和Advice

###### Joint point（连接点）

####### 表示在程序中明确定义的点，包括方法调用，对类成员的访问以及异常处理程序块的执行等

###### Pointcut（切点）

####### 表示通过通配、正则表达式等方式匹配的一组 Joint point

###### Advice（通知）

####### 定义了在 Pointcut 匹配的 Joint point 处具体要执行的操作

###### Target（目标对象）

####### 织入 Advice 的目标对象.

###### Weaving（织入）

####### 组装 Aspect 来创建一个被通知对象。

######  

#######  

##### AOP的实现

###### AspectJ

####### 一门新语言，定义了AOP语法。  

####### 编译期织入代码，使用专门的编译器生成class文件

####### 支持所有的连接点

###### Spring AOP

####### 纯Java实现，不需要专门的编译器和类加载器。

####### 在运行时通过代理的方式织入代码

####### 只支持方法类型的连接点

####### Spring支持对AspectJ的集成

##### Spring AOP

###### JDK动态代理

####### Java提供的动态代理技术，可以在运行时创建接口的代理实例

####### Spring AOP默认采用此种方式，在接口的代理实例中织入代码

###### CGLib动态代理

####### 采用底层的字节码技术，在运行时创建子类代理实例

####### 当目标对象不存在接口时，Spring AOP会采用此种方式，在子类实例中织入代码

#### Spring Bean

##### Bean生命周期

```
/**
 * Actually create the specified bean. 
 * @param beanName the name of the bean
 * @param mbd the merged bean definition for the bean
 * @param args explicit arguments to use for constructor or factory method invocation
 * @return a new instance of the bean
 * @throws BeanCreationException if the bean could not be created
 */
protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)
       throws BeanCreationException {

	BeanWrapper instanceWrapper = null;
	if (mbd.isSingleton()) {
		// 单例模式尝试从缓存中取对象
		instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
	}
	if (instanceWrapper == null) {
		// 实例化 bean 对象，通过工厂方法或构造方法创建 bean 实例
		instanceWrapper = createBeanInstance(beanName, mbd, args);
	}
	final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
	Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);
	mbd.resolvedTargetType = beanType;

	Object exposedObject = bean;
	// 设置 bean 对象属性
	populateBean(beanName, mbd, instanceWrapper);
	if (exposedObject != null) {
		// 初始化 bean 对象
		exposedObject = initializeBean(beanName, exposedObject, mbd);
	}

	return exposedObject;
}

protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
	
	// 若 bean 实现了 BeanNameAware、BeanFactoryAware、BeanClassLoaderAware 等接口，则向 bean 中注入相关对象
	invokeAwareMethods(beanName, bean);

    Object wrappedBean = bean;
    if (mbd == null || !mbd.isSynthetic()) {
        // 执行 bean 初始化前置处理
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    }

	/*
	 * 调用初始化方法：
	 * 1. 若 bean 实现了 InitializingBean 接口，则调用 afterPropertiesSet 方法
	 * 2. 若用户配置了 bean 的 init-method 属性，则调用用户在配置中指定的方法
	 */
	invokeInitMethods(beanName, wrappedBean, mbd);
		
    if (mbd == null || !mbd.isSynthetic()) {
        // 执行 bean 初始化后置处理，AOP 会在此处向目标对象中织入切面逻辑
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }
    return wrappedBean;
}
```

###### 实现*Aware接口

- 让bean能够获取到框架的一些对象
- 只针对实现接口的该Bean

```
private void invokeAwareMethods(final String beanName, final Object bean) {
    if (bean instanceof Aware) {
		// 如果实现了 BeanNameAware 接口，注入 beanName 字符串
        if (bean instanceof BeanNameAware) {
            ((BeanNameAware) bean).setBeanName(beanName);
        }
		// 如果实现了 BeanClassLoaderAware 接口，注入 ClassLoader 对象
        if (bean instanceof BeanClassLoaderAware) {
            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());
        }
		// 如果实现了 BeanFactoryAware 接口，注入 BeanFactory 对象
        if (bean instanceof BeanFactoryAware) {
            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
        }
    }
}
```

####### ApplicationContextAware

######## 获得ApplicationContext对象,可以用来获取所有Bean definition的名字。

####### BeanFactoryAware

######## 获得BeanFactory对象，可以用来检测Bean的作用域。

####### BeanNameAware

######## 获得Bean在配置文件中定义的名字。

###### initialization和destroy

需要在Bean属性值set好之后和Bean销毁之前进行处理时

```
protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)
        throws Throwable {

    // bean 是否实现了 InitializingBean 接口
    boolean isInitializingBean = (bean instanceof InitializingBean);
    if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
		// 调用 afterPropertiesSet 方法执行初始化逻辑
		((InitializingBean) bean).afterPropertiesSet();
    }

    if (mbd != null) {
		// bean 是否配置了 init-method 属性
        String initMethodName = mbd.getInitMethodName();
        if (initMethodName != null && !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
                !mbd.isExternallyManagedInitMethod(initMethodName)) {
            // 调用<bean init-method="init"> 指定初始化方法 init
            invokeCustomInitMethod(beanName, bean, mbd);
        }
    }
}
```

####### 实现 InitializingBean 和 DisposableBean 接口

```
public class GiraffeService implements InitializingBean,DisposableBean {
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("执行InitializingBean接口的afterPropertiesSet方法");
    }
    @Override
    public void destroy() throws Exception {
        System.out.println("执行DisposableBean接口的destroy方法");
    }
}
```

####### 在 bean 的配置文件中指定 init-method 和 destroy-method 方法

```
public class GiraffeService {
    //通过<bean>的destroy-method属性指定的销毁方法
    public void destroyMethod() throws Exception {
        System.out.println("执行配置的destroy-method");
    }
    //通过<bean>的init-method属性指定的初始化方法
    public void initMethod() throws Exception {
        System.out.println("执行配置的init-method");
    }
}
```

####### 使用 @PostConstruct 和 @PreDestroy 注解

```
public class GiraffeService {
    @PostConstruct
    public void initPostConstruct(){
        System.out.println("执行PostConstruct注解标注的方法");
    }
    @PreDestroy
    public void preDestroy(){
        System.out.println("执行preDestroy注解标注的方法");
    }
}
```

###### BeanPostProcessor

- Bean实例化、依赖注入后，在初始化前后制定一些处理操作
- 针对容器中的所有Bean，或者某些Bean

####### postProcessBeforeInitialization( )

######## Bean初始化之前执行

####### postProcessAfterInitialization( )

######## Bean初始化之后执行

######  

#######  

##### Bean的作用域(scope)

###### singleton

####### 单例模式，默认值

###### prototype

####### 每次调用getBean()，返回一个新实例

###### request

####### 每个HTTP请求都创建一个新Bean，仅在当前HTTP request 内有效

###### session

####### 每个HTTP Session对应一个新Bean，仅在当前 HTTP session 内有效

###### globalSession

####### 全局session作用域，仅用于portlet的web应用中

##### Bean加载方式

###### 基于XML的Bean定义

###### 基于注解的Bean定义

####### Bean扫描注解

######## @Component

######### 通用bean注解

######## @Repository

######### 对应持久层（Dao）层

######## @Service

######### 对应服务层

######## @Controller

######### 对应Spring MVC 控制层

####### @ComponentScan

######## 开启组件扫描

####### @Autowired

######## 自动注入bean

####### 作用于类，通过开启组件扫描，自动装配Bean到Spring容器中

###### 基于Java代码装载Bean

####### @Bean

######## 作用于方法

######## 方法中定义并返回bean

####### @Configuration

######## JavaConfig配置类

####### 用于将第三方库中的类装配到Spring容器中

##### Bean单例与线程安全

###### 不定义成员变量

###### @Scope(“prototype”)设为多例

###### 使用ThreadLocal变量

### Spring Data Access

#### Spring 事务管理

##### Spring事务管理接口

###### PlatformTransactionManager 事务管理器

```
Public interface PlatformTransactionManager()...{  
    // 根据指定的传播行为，返回当前活动的事务或创建一个新事务。
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; 
    // 使用事务目前的状态提交事务
    Void commit(TransactionStatus status) throws TransactionException;  
    // 对执行的事务进行回滚
    Void rollback(TransactionStatus status) throws TransactionException;  
 } 

```

####### getTransaction

根据指定的传播行为，返回当前活动的事务或创建一个新事务。

####### commit

####### rollback

###### TransactionDefinition 定义事务属性

```
// @Transactional 注解的事务属性及其默认值
@Transactional(isolation = Isolation.DEFAULT, 
               propagation = Propagation.REQUIRED, 
               timeout = -1, 
               readOnly = false,
               rollbackFor = RuntimeException.class)
```

####### 事务隔离级别 isolation

######## ISOLATION_DEFAULT

使用后端数据库默认的隔离级别，Mysql 默认采用的  REPEATABLE_READ 隔离级别，Oracle 默认采用的 READ_COMMITTED 隔离级别.

######## ISOLATION_READ_UNCOMMITTED

可能会导致脏读、幻读或不可重复读

######## ISOLATION_READ_COMMITTED

可以阻止脏读，但是幻读或不可重复读仍有可能发生

######## ISOLATION_REPEATABLE_READ

可以阻止脏读和不可重复读，但幻读仍有可能发生

######## ISOLATION_SERIALIZABLE

可以防止脏读、不可重复读以及幻读，但是将严重影响程序的性能。

####### 事务传播行为 propagation

当前事务方法被另一事务方法调用是，指定事务如何传播。


######## 支持当前事务

######### PROPAGATION_REQUIRED

requires

########## 如果当前存在事务，则加入该事务；否则，则创建一个新的事务。

######### PROPAGATION_SUPPORTS

########## 如果当前存在事务，则加入该事务；否则，以非事务的方式继续运行。

######### PROPAGATION_MANDATORY

（mandatory：强制性）

########## 如果当前存在事务，则加入该事务；否则，抛出异常。

######## 不支持当前事务

######### PROPAGATION_REQUIRES_NEW

########## 创建一个新的事务，如果当前存在事务，则把当前事务挂起。

######### PROPAGATION_NOT_SUPPORTED

########## 以非事务方式运行，如果当前存在事务，则把当前事务挂起。

######### PROPAGATION_NEVER

########## 以非事务方式运行，如果当前存在事务，则抛出异常。

######## PROPAGATION_NESTED

######### 如果当前存在事务，则创建一个事务（独立的提交和回滚）嵌套到当前事务内；否则，则等价于REQUIRED。

####### 事务超时时间 timeout

######## 如果超过该时间限制但事务还没有完成，则自动回滚事务。

####### 是否只读事务 readOnly

######## 对事务资源是否只执行只读操作

####### 事务回滚规则 rollbackFor

######## 用于指定能够触发事务回滚的异常类型

###### TransactionStatus 记录事务的状态

##### Spring事务管理方式

###### 声明式事务

在配置文件中配置（推荐使用）

####### 基于 XML 配置

实际是基于 AspectJ (AOP) 实现

####### 基于 @Transactional 注解

###### 编程式事务

在代码中硬编码(不推荐使用)

####### 通过 TransactionTemplate 手动管理事务

只在业务方法较复杂，要求方法中的小部分代码是事务时才使用。
```

transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

transactionTemplate.execute(new TransactionCallback<Object>() {
	@Override
	public Object doInTransaction(TransactionStatus transactionStatus) {
    
		...
	}
});
```

#### MyBatis

##### JDBC

JDBC（Java DataBase Connectivity）是Java和数据库之间的一个桥梁，是一个规范而不是一个实现，能够执行SQL语句。它由一组用Java语言编写的类和接口组成。

######  

##### #{} 和 ${} 的区别

###### #{}

####### 是预编译处理，先将#{}替换为？，再用PreparedStatement的set方法赋值

###### ${}

####### 是字符串替换，${}替换为变量的值

###### 预编译

预编译指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。

####### 预编译后DBMS无需再次编译，可防止SQL注入

####### 预编译语句对象可以重复利用，性能更高

sql 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个sql，可以直接使用这个缓存的 PreparedState 对象。

#### JavaWEB 数据库连接

#####  

##### 最小连接数

###### 一直保持的数据库连接，请求无需创建连接，直接使用

##### 最大连接数

###### 请求超过最小连接数后要创建连接，使用后不会立马释放，超过最大连接数会进入等待队列

##### 解决创建数据库连接花费系统开销浪费系统资源和可能产生数据库服务器内存溢出和宕机

### Web Servlet

#### servlet

##### servlet 生命周期

###### init() 初始化

当Servlet第一次被请求时，Servlet容器就会开始调用该方法来初始化一个Servlet对象出来。

######  service()处理客户端请求

每当请求Servlet时，Servlet容器调用该方法，根据不同的请求方式进行不同的处理。

####### doGet() 处理 GET 类型的请求

####### doPost() 处理 POST 类型的请求

###### destroy()释放资源 

在服务器关闭时，执行该方法，将所有 servlet 卸载。

##### Tomcat

###### Tomcat 是 Web 应用服务器,是一个 Servlet / JSP 容器. 负责处理客户请求,把请求传送给 Servlet, 并将 Servlet 的响应传送回给客户.

##### 

######  

#### SpringMVC

#####  

######  

##### 工作原理  

```
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
	
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
	ModelAndView mv = null;

	mappedHandler = getHandler(processedRequest);

	HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

	if (!mappedHandler.applyPreHandle(processedRequest, response)) {
		return;
	}

	mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    
	mappedHandler.applyPostHandle(processedRequest, response, mv);
	
    Locale locale = this.localeResolver.resolveLocale(request);
    response.setLocale(locale);

    View view;
 
	// 若 mv 中的 view 是 String 类型，即处理器返回的是模板名称，将其解析为具体的 View 对象
    if (mv.isReference()) {
        view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
    }
    else {
        view = mv.getView();
    }

	view.render(mv.getModelInternal(), request, response);

}
```

###### Servlet 容器接收浏览器发来的请求，并将请求委托给 DispatcherServlet 处理

###### DispatcherServlet 将 HttpServletRequest 传给 HandlerMapping， 返回包含拦截器和 Handler 的 HandelExecutionChain

###### 对处理器进行适配，获取可执行处理器方法的适配器 HandlerAdapter

###### 执行拦截器 preHandle 方法

###### 通过 HandlerAdapter 调用处理器方法，返回 ModelAndView

###### 执行拦截器 PostHandle 方法

###### 将视图名解析成物理视图名(具体的页面地址)，再生成并返回视图对象

###### 对 View 进行渲染, 然后执行拦截器 afterCompletion 方法，最后将渲染结果返回给用户

##### 重要组件

###### 框架提供

####### 前端控制器 DispatcherServlet

######## Spring MVC 的核心组件，是请求的入口，负责协调各个组件工作降低了组件之间的耦合度

####### 处理器映射器 HandlerMapping

######## 内部维护了 <URL, Handler> 映射，负责为请求找到合适的处理器

####### 处理器适配器 HandlerAdapter

######## 根据特定规则执行 Handler，返回 ModelAndView

Spring 中的处理器的实现多变，比如用户处理器可以实现 Controller 接口，也可以用 @RequestMapping 注解将方法作为一个处理器等，这就导致 Spring 不知道怎么调用用户的处理器逻辑。所以这里需要一个处理器适配器，由处理器适配器去调用处理器的逻辑

####### 视图解析器 View Resolver

######## 用于将视图名称解析为视图对象 View

###### 手动开发

####### 处理器 Handler

######## 即Controller 控制器, 一般情况需要工程师根据业务需求开发 Handler

编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler

####### 视图 View

######## 视图对象用于将模板渲染成 html 或其他类型的文件。比如 InternalResourceView 可将 jsp 渲染成 html。

## 项目

### Community

#### 登录模块

##### Spring Email

###### 导入 Jar 包

```
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-mail</artifactId>
    <version>2.1.5.RELEASE</version>
</dependency>
```

####### 邮箱参数配置

```
# MailProperties
spring.mail.host=smtp.sina.cn
spring.mail.port=465
spring.mail.username=15627236086m@sina.cn
spring.mail.password=e98e2fe67a9278fe
spring.mail.protocol=smtps
spring.mail.properties.mail.smtp.ssl.enable=true
```

######## 使用 JavaMailSender 发送邮件

```
@Component // 表示由spring容器管理，通用的bean
public class MailClient {

    private static final Logger logger = LoggerFactory.getLogger(MailClient.class);

    @Autowired
    private JavaMailSender mailSender;

    // 注入配置文件中设定的username
    @Value("${spring.mail.username}")
    private String from;

    public void sendMail(String to, String subject, String content) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            // 构建邮箱
            MimeMessageHelper helper = new MimeMessageHelper(message);
            helper.setFrom(from);
            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(content, true); // 支持发送html文件
            // 发送邮件
            mailSender.send(helper.getMimeMessage());
        } catch (MessagingException e) {
            logger.error("发送邮件失败：" + e.getMessage());
        }
    }
}
```

######### 使用 ThymeLeaf 发送 HTML 邮件

```
public class MailTests {

    @Autowired
    private MailClient mailClient;

    // thymeleaf模板引擎类
    @Autowired
    private TemplateEngine templateEngine;

    @Test
    public void testTextMail() {
        mailClient.sendMail("731276899@qq.com", "TEST", "Welcome");
    }

    @Test
    public void testHtmlMail() {
        // 构造模板参数
        Context context = new Context();
        context.setVariable("username", "sunday");

        // 调用模板引擎生成动态网页
        String content = templateEngine.process("/mail/demo", context);
        System.out.println(content);

        // 发送HTML邮件
        mailClient.sendMail("Xiecz0513@outlook.com", "HTML", content);
    }
}
```

##### 开发注册功能

###### 接受用户表单提交的数据

```
/**
 * 用户提交注册数据
 * @param model
 * @param user 网页传入的参数中与user的属性相匹配时，SpringMVC会自动将参数
 *             传入user对象的属性中。
 * @return
 */
@RequestMapping(path = "/register", method = RequestMethod.POST)
public String register(Model model, User user) {
	Map<String, Object> map = userService.register(user);
	if (map == null || map.size() == 0) {
		model.addAttribute("msg", "注册成功，我们已经向您的邮箱发送了一封激活邮件，请尽快激活！");
		model.addAttribute("target", "/index");
		return "/site/operate-result";
	} else {
		model.addAttribute("usernameMsg", map.get("usernameMsg"));
		model.addAttribute("passwordMsg", map.get("passwordMsg"));
		model.addAttribute("emailMsg", map.get("emailMsg"));
		return "/site/register";
	}
}
```

####### 验证数据，注册账号，邮件发送激活码

```
public Map<String, Object> register(User user) {
	Map<String, Object> map = new HashMap<>();

	// 空值处理
	if (user == null) {
		throw new IllegalArgumentException("参数不能为空！");
	}
	if (StringUtils.isBlank(user.getUsername())) {
		map.put("usernameMsg", "账号不能为空！");
		return map;
	}
	if (StringUtils.isBlank(user.getPassword())) {
		map.put("passwordMsg", "密码不能为空！");
		return map;
	}
	if (StringUtils.isBlank(user.getEmail())) {
		map.put("emailMsg", "邮箱不能为空！");
		return map;
	}

	// 验证账号
	User u = userMapper.selectByName(user.getUsername());
	if (u != null) {
		map.put("usernameMsg", "该账户已存在！");
		return map;
	}

	// 验证邮箱
	u = userMapper.selectByEmail(user.getEmail());
	if (u != null) {
		map.put("emailMsg", "该邮箱已被注册！");
		return map;
	}

	// 注册用户
	user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
	user.setPassword(CommunityUtil.md5(user.getPassword() + user.getSalt()));
	user.setType(0);
	user.setStatus(0);
	user.setActivationCode(CommunityUtil.generateUUID());
	user.setHeaderUrl(String.format("http://images.nowcoder.com/head/%dt.png", new Random().nextInt(1000)));
	user.setCreateTime(new Date());
	userMapper.insertUser(user);

	// 邮箱发送激活码
	Context context = new Context();
	context.setVariable("email", user.getEmail());
	// http://localhost:8080/community/activation/101/code
	String url = domain + contextPath + "/activation/" + user.getId() + "/" + user.getActivationCode();
	context.setVariable("url", url);
	String content = templateEngine.process("/mail/activation", context);
	mailClient.sendMail("Xiecz0513@outlook.com", "账号激活", content);

	return map;
}
```

######## 激活账号

```
// http://localhost:8080/community/activation/101/code
@RequestMapping(path = "/activation/{userId}/{code}", method = RequestMethod.GET)
public String activation (Model model, @PathVariable("userId") int userId, 
@PathVariable("code") String code) {

	int result = userService.activation(userId, code);
    
	if (result == ACTIVATION_SUCCESS) {
		model.addAttribute("msg", "激活成功，您的账号现在可以正常使用了！");
		model.addAttribute("target", "/login");
	} else if (result == ACTIVATION_REPEAT) {
		model.addAttribute("msg", "操作无效，您的账号已经激活过了！");
		model.addAttribute("target", "/index");
	} else {
		model.addAttribute("msg", "激活失败，您提供的验证码不正确！");
		model.addAttribute("target", "/index");
	}
	return "/site/operate-result";
}
```
```
public int activation(int userId, String code) {
	User user = userMapper.selectById(userId);
	if (user.getStatus() == 1) {
		return ACTIVATION_REPEAT;
	} else if (user.getActivationCode().equals(code)) {
		userMapper.updateStatus(userId, 1);
		return ACTIVATION_SUCCESS;
	} else {
		return ACTIVATION_FAILURE;
	}
}
```

##### 会话管理

###### Cookie 实例

```
// Cookie示例

@RequestMapping(path = "/cookie/set", method = RequestMethod.GET)
@ResponseBody
public String setCookie(HttpServletResponse response) {
	// 创建Cookie
	Cookie cookie = new Cookie("code", CommunityUtil.generateUUID());
	// 设置Cookie生效的范围
	cookie.setPath("/community/alpha");
	// 设置Cookie生存时间, 未设置的话关闭浏览器就清除Cookie
	cookie.setMaxAge(60 * 10);
	// 发送Cookie
	response.addCookie(cookie);

	return "set Cookie";
}

/**
 * @param code @CookieValue("code")注解获取浏览器回传的指定Cookie。
 * @return
 */
@RequestMapping(path = "/cookie/get", method = RequestMethod.GET)
@ResponseBody
public String getCookie(@CookieValue("code") String code) {
	System.out.println(code);
	return "get Cookie";
}
```

####### request 中遍历查找相应的 Cookie

```
// 自定义工具类，该类只是用于调用静态方法，只会在调用时加载类，不会创建对象，因此不需要放在IOC容器中
public class CookieUtil {
    public static String getValue(HttpServletRequest request, String name) {
        if (request == null || name == null) {
            throw new IllegalArgumentException("参数为空！");
        }

        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(name)) {
                    return cookie.getValue();
                }
            }
        }

        return null;
    }
}
```

###### Session示例

```
// Session示例

/**
 * @param session SpringMVC自动创建Session并注入。
 * @return
 */
@RequestMapping(path = "/session/set", method = RequestMethod.GET)
@ResponseBody
public String setSession(HttpSession session) {
	session.setAttribute("id", 1);
	session.setAttribute("name", "Test");
	return "set session";
}

@RequestMapping(path = "/session/get", method = RequestMethod.GET)
@ResponseBody
public String getSession(HttpSession session) {
	System.out.println(session.getAttribute("id"));
	System.out.println(session.getAttribute("name"));
	return "get session";
}
```

##### Kaptcha 生成验证码

###### 导入 jar 包 

```
<dependency>
	<groupId>com.github.penggle</groupId>
	<artifactId>kaptcha</artifactId>
	<version>2.3.2</version>
</dependency>
```

####### 编写 Kaptcha 配置类

```
@Configuration
public class KaptchaConfig {

    @Bean
    public Producer kaptchaProducer() {
        Properties properties = new Properties();
        properties.setProperty("kaptcha.image.width", "100");
        properties.setProperty("kaptcha.image.height", "40");
        properties.setProperty("kaptcha.textproducer.font.size", "32");
        properties.setProperty("kaptcha.textproducer.font.color", "0,0,0");
        properties.setProperty("kaptcha.textproducer.char.string", "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        properties.setProperty("kaptcha.textproducer.char.length", "4");
        properties.setProperty("kaptcha.noise.impl", "com.google.code.kaptcha.impl.NoNoise");

        DefaultKaptcha kaptcha = new DefaultKaptcha();
        Config config = new Config(properties);
        kaptcha.setConfig(config);
        return kaptcha;
    }
}
```

######## 生成验证码、生成图片

```
@RequestMapping(path = "/kaptcha", method = RequestMethod.GET)
public void getKaptcha(HttpServletResponse response, HttpSession session) {
	// 生成验证码
	String text = kaptchaProducer.createText();
	BufferedImage image = kaptchaProducer.createImage(text);

	// 将验证码存入session
	session.setAttribute("kaptcha", text);

	// 将图片输出给浏览器
	response.setContentType("image/png");
	try {
		OutputStream os = response.getOutputStream();
		ImageIO.write(image, "png", os);
	} catch (IOException e) {
		logger.error("响应验证码失败:" + e.getMessage());
	}
}
```

##### 开发登录、退出功能

###### 登录时，验证账号、密码、验证码，发送登录凭证

```
@RequestMapping(path = "/login", method = RequestMethod.POST)
public String login(String username, String password, String code, boolean rememberme,
					Model model, HttpSession session, HttpServletResponse response) {
	// 检测验证码
	String kaptcha = (String) session.getAttribute("kaptcha");
	if (StringUtils.isBlank(kaptcha) || StringUtils.isBlank(code) || !kaptcha.equalsIgnoreCase(code)) {
		model.addAttribute("codeMsg", "验证码不正确！");
		return "/site/login";
	}

	// 检查账号，密码
	int expiredSecondes = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;
	Map<String, Object> map = userService.login(username, password, expiredSecondes);
	if (map.containsKey("ticket")) {
    	// 成功时将登录凭证发送给客户端
		Cookie cookie = new Cookie("ticket", map.get("ticket").toString());
		cookie.setPath(contextPath);
		cookie.setMaxAge(expiredSecondes);
		response.addCookie(cookie);
		// 重定向到首页
		return "redirect:/index";
	} else {
		model.addAttribute("usernameMsg", map.get("usernameMsg"));
		model.addAttribute("passwordMsg", map.get("passwordMsg"));
		return "/site/login";
	}
}
```


####### 成功时，生成登录凭证

```
public Map<String, Object> login(String username, String password, int expiredSeconds) {
	Map<String, Object> map = new HashMap<>();

	// 空值处理
	if (StringUtils.isBlank(username)) {
		map.put("usernameMsg", "账号不能为空");
		return map;
	}
	if (StringUtils.isBlank(password)) {
		map.put("passwordMsg", "密码不能为空");
		return map;
	}

	// 验证账号
	User user = userMapper.selectByName(username);
	if (user == null) {
		map.put("usernameMsg", "该账号不存在！");
		return map;
	}

	// 验证密码
	password = CommunityUtil.md5(password + user.getSalt());
	if (!user.getPassword().equals(password)) {
		map.put("passwordMsg", "密码不正确!");
		return map;
	}

	// 生成登录凭证
	LoginTicket loginTicket = new LoginTicket();
	loginTicket.setUserId(user.getId());
	loginTicket.setTicket(CommunityUtil.generateUUID());
	loginTicket.setStatus(0);
	loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));
	loginTicketMapper.insertLoginTicket(loginTicket);

	map.put("ticket", loginTicket.getTicket());
	return map;
}

```

###### 退出时，将登录凭证改为失效状态

```
@RequestMapping(path = "/logout", method = RequestMethod.GET)
public String logout(@CookieValue("ticket") String ticket) {
	userService.logout(ticket);
	// login方法分get请求和post请求，重定向是默认是get请求
	return "redirect:/login";
}
```
```
public void logout(String ticket) {
	loginTicketMapper.updateStatus(ticket, 1);
}
```

##### 显示登录信息

###### 定义拦截器，实现 HandlerInterceptor 接口

```
// 浏览器向服务器发出请求时，服务器创建一个线程来处理请求，当服务器发出响应后，该线程才被销毁。
@Component
public class LoginTicketInterceptor implements HandlerInterceptor {
    @Autowired
    private UserService userService;

    @Autowired
    private HostHolder hostHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
    		Object handler) throws Exception {
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, 
    		Object handler, ModelAndView modelAndView) throws Exception {
    
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
    		Object handler, Exception ex) throws Exception {
    
    }
}
```

####### 请求前查询并持有登录用户数据

```
// 在Controller之前执行
@Override
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, 
		Object handler) throws Exception {
	// 从Cookie中获取凭证
	String ticket = CookieUtil.getValue(request, "ticket");

	if (ticket != null) {
		// 查询凭证
		LoginTicket loginTicket = userService.findLoginTicket(ticket);
		// 检查凭证是否有效
		if (loginTicket != null && loginTicket.getStatus() == 0 && 
        		loginTicket.getExpired().after(new Date())) {
			// 根据凭证查询用户
			User user = userService.findUserById(loginTicket.getUserId());
			// 在本次请求中持有用户
			hostHolder.setUser(user);
		}
	}

	return true;
}
```

####### 在模板视图上显示用户数据

```
// 在Controller之后，TemplateEngine之前执行
@Override
public void postHandle(HttpServletRequest request, HttpServletResponse response, 
		Object handler, ModelAndView modelAndView) throws Exception {
	User user = hostHolder.getUser();
	if (user != null && modelAndView != null) {
		modelAndView.addObject("loginUser", user);
	}
}
```

####### 在请求结束时清理用户数据

```
// 在TemplateEngine之后执行
@Override
public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
		Object handler, Exception ex) throws Exception {
	hostHolder.clear();
}
```

###### 配置拦截器，实现 WebMvcConfigurer 接口

```
// 该配置类不是为了实现第三方的Bean，只是为了实现一个接口来配置拦截器
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private LoginTicketInterceptor loginTicketInterceptor;
	
    // 指定拦截器和排除的路径
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
    	registry.addInterceptor(loginTicketInterceptor)
                .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");
    }
}
```

##### 账户设置

###### SpringMVC 使用 MultipartFile 上传头像

```
// 存放上传文件的本地路径
@Value("${community.path.upload}")
private String uploadPath;

// 必须为 Post 请求
@RequestMapping(path = "/upload", method = RequestMethod.POST)
public String uploadHeader(MultipartFile headerImage, Model model) {

	if (headerImage == null) {
		model.addAttribute("error", "您还没有选择图片！");
		return "/site/setting";
	}
	
    // 提取文件后缀
	String fileName = headerImage.getOriginalFilename();
	String suffix = fileName.substring(fileName.lastIndexOf("."));
	if (StringUtils.isBlank(suffix)) {
		model.addAttribute("error", "文件的格式不正确！");
		return "/site/setting";
	}

	// 生成随机文件名
	fileName = CommunityUtil.generateUUID() + suffix;
	// 确定文件存放的路径
	File dest = new File(uploadPath + "/" + fileName);
	try {
		// 存储文件
		headerImage.transferTo(dest);
	} catch (IOException e) {
		logger.error("上传文件失败：" + e.getMessage());
		throw new RuntimeException("上传文件失败，服务器发生异常！", e);
	}

	// 更新当前用户的头像的路径(web访问路径)
	// http://localhost:8080/community/user/header/xxx.png
	User user = hostHolder.getUser();
	String headerUrl = domain + "/" + contextPath + "/user/header/" + fileName;
	userService.updateHeader(user.getId(), headerUrl);

	return "redirect:/index";
}
```


###### 通过流向浏览器输出头像显示

```
// 返回的既不是html也不是String, 为void，因为是通过流向浏览器输出
@RequestMapping(path = "/header/{fileName}", method = RequestMethod.GET)
public void getHeader(@PathVariable("fileName") String fileName, HttpServletResponse response) {
	// 服务器存放路径
	fileName = uploadPath + "/" + fileName;
	// 文件后缀
	String suffix = fileName.substring(fileName.lastIndexOf("."));
	// 响应图片
	response.setContentType("image/" + suffix);
	try (
			FileInputStream fis = new FileInputStream(fileName);
	) {
		OutputStream os = response.getOutputStream();
		byte[] buffer = new byte[1024];
		int b = 0;
		while ((b = fis.read(buffer)) != -1) {
			os.write(buffer, 0, b);
		}
	} catch (IOException e) {
		logger.error("读取头像失败：" + e.getMessage());
	}
}

```

##### 检查登录状态

###### 自定义登录检查注解, 并给所需拦截的方法加上注解

```
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LoginRequired {

}
```
元注解
`@Target`：声明注解范围
 - `TYPE：接口、类、枚举、注解`
 - `FIELD：字段、枚举的常量`
 - `METHOD：方法`
 - `PARAMETER：方法参数`
 - `CONSTRUCTOR：构造函数`
 - `LOCAL_VARIABLE：局部变量`
 - `ANNOTATION_TYPE：注解`
 - `PACKAGE：包` 
 
`@Retention`：注解的保留位置
 - `SOURCE：注解仅存在于源码中，在class字节码文件中不包含`
 - `CLASS：默认的保留策略，注解在class字节码文件中存在，但运行时无法获得`
 - `RUNTIME：注解在class字节码文件中存在，在运行时可以通过反射获取到`
 
`@Document`：声明注解能够被javadoc等识别

`@Inherited`：声明子类可以继承此注解

####### 定义登录检测拦截器，利用反射读取方法上的注解

```
@Component
public class LoginRequiredInterceptor implements HandlerInterceptor {

    @Autowired
    private HostHolder hostHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
    		Object handler) throws Exception {

        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            Method method = handlerMethod.getMethod();
            // 利用反射读取方法上的注解
            LoginRequired loginRequired = method.getAnnotation(LoginRequired.class);
            if (loginRequired != null && hostHolder.getUser() == null) {
                response.sendRedirect(request.getContextPath() + "/login");
                return false;
            }
        }
        return true;
    }
}
```

######## 拦截器配置类中添加该拦截器

```
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private AlphaInterceptor alphaInterceptor;

    @Autowired
    private LoginTicketInterceptor loginTicketInterceptor;

    @Autowired
    private LoginRequiredInterceptor loginRequiredInterceptor;

    // 配置多个拦截器的调用顺序如下：
    // preHandle按拦截器配置顺序调用
    // postHandler按拦截器配置逆序调用
    // afterCompletion按拦截器配置逆序调用
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
       registry.addInterceptor(loginTicketInterceptor)
                .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");

        registry.addInterceptor(loginRequiredInterceptor)
                .excludePathPatterns("/**/*.css", "/**/*.js", "/**/*.png", "/**/*.jpg", "/**/*.jpeg");
    }
}
```

#### 核心模块

##### 过滤敏感词

###### 定义前缀树

```
	// 前缀树结点
    private class TrieNode {

        // 关键词结束符号
        private boolean isKeywordEnd = false;

        // 子节点(key是下级字符，value是下级节点)
        private Map<Character, TrieNode> subNodes = new HashMap<>();

        public boolean isKeywordEnd() {
            return isKeywordEnd;
        }

        public void setKeywordEnd(boolean keywordEnd) {
            isKeywordEnd = keywordEnd;
        }

        // 添加子节点
        public void addSubNode(Character c, TrieNode node) {
            subNodes.put(c, node);
        }

        // 获取子节点
        public TrieNode getSubNode(Character c) {
            return subNodes.get(c);
        }
    }
```

###### 根据敏感词初始化前缀树

```
@Component
public class SensitiveFilter {

    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);

    // 替换法
    private static final String REPLACEMENT = "***";

    // 根节点
    private TrieNode rootNode = new TrieNode();

    @PostConstruct
    public void init() {
        try (
            InputStream is = this.getClass().getClassLoader()
            		.getResourceAsStream("sensitive-words.txt");
            BufferedReader reader = new BufferedReader(new InputStreamReader(is));
            ) {
                String keyword;
                while (((keyword = reader.readLine()) != null)) {
                     this.addKeyword(keyword);
                }
        } catch (IOException e) {
            logger.error("加载敏感词文件失败: " + e.getMessage());
        }
    }

    // 将一个敏感词加入前缀树中
    private void addKeyword(String keyword) {
        TrieNode tempNode = rootNode;
        for (int i = 0; i < keyword.length(); i++) {
            char c = keyword.charAt(i);
            TrieNode subNode = tempNode.getSubNode(c);

            if (subNode == null) {
                // 初始化子节点
                subNode = new TrieNode();
                tempNode.addSubNode(c, subNode);
            }

            // 指向子节点，进入下一轮循环
            tempNode = subNode;

            // 设置结束标志
            if (i == keyword.length() - 1) {
                tempNode.setKeywordEnd(true);
            }
        }
    }
```

###### 编写过滤敏感词方法

```
    /**
     * 过滤敏感词
     *
     * @param text
     * @return
     */
    public String filter(String text) {
        if (StringUtils.isBlank(text)) {
            return null;
        }

        // 指针1
        TrieNode tempNode = rootNode;
        // 指针2
        int begin = 0;
        // 指针3
        int position = 0;
        // 结果
        StringBuilder sb = new StringBuilder();

        while (position < text.length()) {
            char c = text.charAt(position);

            // 跳过符号
            if (isSymbol(c)) {
                // 若指针1处于根节点，将此符号计入结果，让指针2向下走一步
                if (tempNode == rootNode) {
                    sb.append(c);
                    begin++;
                }
                // 无论符号在开头或中间，指针3都向下走一步
                position++;
                continue;
            }

            // 检查下级节点
            tempNode = tempNode.getSubNode(c);
            if (tempNode == null) {
                // 以begin开头的字符串不是敏感词
                sb.append(text.charAt(begin));
                // 进入下一个位置
                position = ++begin;
                // 重新指向根节点
                tempNode = rootNode;
            } else if (tempNode.isKeywordEnd()) {
                // 发现敏感词，将begin~position字符串替换掉
                sb.append(REPLACEMENT);
                // 进入下一个位置
                begin = ++position;
                // 重新指向根节点
                tempNode = rootNode;
            } else {
                // 检查下一个字符
                position++;
            }
        }

        // 将最后一批字符计入结果
        sb.append(text.substring(begin));

        return sb.toString();
    }

    // 判断是否为符号
    private boolean isSymbol(Character c) {
        // 0x2E80~0x9FFF 是东亚文字范围
        return !CharUtils.isAsciiAlphanumeric(c) && (c < 0x2E80 || c > 0x9FFF);
    }
```

##### 发布贴子

###### 使用 jQuery 发送 AJAX 请求，并接受响应

```
function publish() {
	$("#publishModal").modal("hide");

	// 获取标题和内容
	var title = $("#recipient-name").val();
	var content = $("#message-text").val();
	// 发送异步请求(POST)
	$.post(
		CONTEXT_PATH + "/discuss/add",
		{"title":title, "content":content},
        // 回调函数，接受返回的响应
		function (data) {
			data = $.parseJSON(data);
			// 在提示框中显示返回信息
			$("#hintBody").text(data.msg);
			// 显示提示框
			$("#hintModal").modal("show");
			// 2秒后，自动隐藏提示框
			setTimeout(function () {
				$("#hintModal").modal("hide");
				// 刷新页面
				if (data.code == 0) {
					window.location.reload();
				}
			}, 2000)
		}
	);
 }
```

###### 接受 AJAX 请求，并生成贴子

```
    @RequestMapping(path = "/add", method = RequestMethod.POST)
    @ResponseBody
    public String addDiscussPost(String title, String content) {
        User user = hostHolder.getUser();
        if (user == null) {
            return CommunityUtil.getJSONString(403, "你还没有登录哦！");
        }

        DiscussPost post = new DiscussPost();
        post.setUserId(user.getId());
        post.setTitle(title);
        post.setContent(content);
        post.setCreateTime(new Date());
        discussPostService.addDiscussPost(post);

        // 报错的情况，将来统一处理。
        return CommunityUtil.getJSONString(0, "发布成功！");
    }
```

####### 对贴子进行处理并插入向数据库

```
    public int addDiscussPost(DiscussPost post) {
        if (post == null) {
            throw new IllegalArgumentException("参数不能为空！");
        }

        // 转义HTML标记
        post.setTitle(HtmlUtils.htmlEscape(post.getTitle()));
        post.setContent(HtmlUtils.htmlEscape(post.getContent()));

        // 过滤敏感词
        post.setTitle(sensitiveFilter.filter(post.getTitle()));
        post.setContent(sensitiveFilter.filter(post.getContent()));

        return discussPostMapper.insertDiscussPost(post);
    }
```

##### 事务管理

###### 声明式事务 与 编程式事务 示例

```
// REQUIRED: 支持当前事务（外部事务），如果不存在则创建新事务。
// REQUIRES_NEW: 创建一个新事务，并且暂停当前事务（外部事务）。
// NESTED: 如果当前存在事务（外部事务），则嵌套在该事务中执行（独立的提交和回滚），否则就和REQUIRED一样。
@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
public Object save1() {
	// 新增用户
	User user = new User();
	user.setUsername("alpha");
	user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
	user.setPassword(CommunityUtil.md5("123" + user.getSalt()));
	user.setEmail("alpha@qq,com");
	user.setHeaderUrl("http://image.nowcode.com/head/99t.png");
	user.setCreateTime(new Date());
	userMapper.insertUser(user);

	// 新增贴子
	DiscussPost post = new DiscussPost();
	post.setUserId(user.getId());
	post.setTitle("Hello");
	post.setContent("新人报道！");
	post.setCreateTime(new Date());
	discussPostMapper.insertDiscussPost(post);

	Integer.valueOf("abc");

	return "ok";
}

@Autowired
private TransactionTemplate transactionTemplate;

public Object save2() {
	transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);
	transactionTemplate.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

	return transactionTemplate.execute(new TransactionCallback<Object>() {
		@Override
		public Object doInTransaction(TransactionStatus transactionStatus) {
			// 新增用户
			User user = new User();
			user.setUsername("beta");
			user.setSalt(CommunityUtil.generateUUID().substring(0, 5));
			user.setPassword(CommunityUtil.md5("123" + user.getSalt()));
			user.setEmail("beta@qq,com");
			user.setHeaderUrl("http://image.nowcode.com/head/999t.png");
			user.setCreateTime(new Date());
			userMapper.insertUser(user);

			// 新增贴子
			DiscussPost post = new DiscussPost();
			post.setUserId(user.getId());
			post.setTitle("你好");
			post.setContent("我是新人！");
			post.setCreateTime(new Date());
			discussPostMapper.insertDiscussPost(post);

			Integer.valueOf("abc");

			return "ok";
		}
	});
}
```

###### 添加评论时同时更新贴子中的评论数

```
@Transactional(isolation = Isolation.READ_COMMITTED, propagation = Propagation.REQUIRED)
public int addComment(Comment comment) {
	if (comment == null) {
		throw new IllegalArgumentException("参数不能为空");
	}

	// 添加评论
	comment.setContent(HtmlUtils.htmlEscape(comment.getContent()));
	comment.setContent(sensitiveFilter.filter(comment.getContent()));
	int rows = commentMapper.insertComment(comment);

	// 更新贴子评论数量
	if (comment.getEntityType() == ENTITY_TYPE_POST) {
		int count = commentMapper.selectCountByEntity(comment.getEntityType(), comment.getEntityId());
		discussPostService.updateCommentCount(comment.getEntityId(), count);
	}

	return rows;
}
```

##### 显示和添加贴子、评论、私信

###### entity中定义实体类 -> dao中创建Mapper接口 -> mapper中创建mapper.xml编写sql -> service中创建Service类 -> Controller中添加处理请求的方法 -> 对应html中修改动态链接

##### 发送私信

###### 采用异步方式发送私信

```
@RequestMapping(path = "/letter/send", method = RequestMethod.POST)
@ResponseBody
public String sendLetter(String toName, String content) {
	User target = userService.findUserByName(toName);
	if (target == null) {
		return CommunityUtil.getJSONString(1, "目标用户不存在！");
	}

	Message message = new Message();
	message.setFromId(hostHolder.getUser().getId());
	message.setToId(target.getId());
	if (message.getFromId() < message.getToId()) {
		message.setConversationId(message.getFromId() + "_" + message.getToId());
	} else {
		message.setConversationId(message.getToId() + "_" + message.getFromId());
	}
	message.setContent(content);
	message.setCreateTime(new Date());
	messageService.addMessage(message);

	return CommunityUtil.getJSONString(0);
}
```

###### 访问私信时，将状态设为已读

```
@RequestMapping(path = "/letter/detail/{conversationId}", method = RequestMethod.GET)
public String getLetterDetail(@PathVariable("conversationId") String conversationId, 
		Model model, Page page) {
	// 分页信息
	page.setLimit(5);
	page.setPath("/letter/detail/" + conversationId);
	page.setRows(messageService.findLetterCount(conversationId));

	// 私信列表
	List<Message> letterList = messageService.findLetters(conversationId, 
    		page.getOffset(), page.getLimit());
	List<Map<String, Object>> letters = new ArrayList<>();
	if (letterList != null) {
		for (Message message : letterList) {
			Map<String, Object> map = new HashMap<>();
			map.put("letter", message);
			map.put("fromUser", userService.findUserById(message.getFromId()));

			letters.add(map);
		}
	}
	model.addAttribute("letters", letters);

	// 私信目标
	model.addAttribute("target", getLetterTarget(conversationId));

	// 设置已读
	List<Integer> ids = getLetterIds(letterList);
	if (!ids.isEmpty()) {
		messageService.readMessage(ids);
	}

	return "/site/letter-detail";
}
```

##### 统一异常处理

###### 发生异常时跳转页面

```
@RequestMapping(path = "/error", method = RequestMethod.GET)
public String getErrorPage() {
	return "/error/500";
}
```

###### 对所有 Controller 的异常统一处理

```
// 对每个带Controller注释的代码进行扫描，捕获异常
@ControllerAdvice(annotations = Controller.class)
public class ExceptionAdvice {

    private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);

    @ExceptionHandler({Exception.class})
    public void handleException(Exception e, HttpServletRequest request, 
    		HttpServletResponse response) throws IOException {
            
        logger.error("服务器发生异常：" + e.getMessage());
        
        for (StackTraceElement element : e.getStackTrace()) {
            logger.error(element.toString());
        }
		
        // 判断是否是异步请求
        String xRequestedWith = request.getHeader("x-requested-with");
        if ("XMLHttpRequest".equals(xRequestedWith)) {
        	// 异步请求返回字符串提示
            response.setContentType("application/plain;charset=utf-8");
            PrintWriter writer = response.getWriter();
            writer.write(CommunityUtil.getJSONString(1, "服务器异常！"));
        } else {
        	// 非异步请求返回错误页面
            response.sendRedirect(request.getContextPath() + "/error");
        }
    }
}
```

###### @ControllerAdvice

- 用于修饰类，表示该类是Controller的全局配置类。
- 在此类中，可以对Controller进行如下三种全局配置：异常处理方案、绑定数据方案、绑定参数方案。

####### @ExceptionHandler

- 用于修饰方法，该方法会在Controller出现异常后被调用，用于处理捕获到的异常。

####### @ModelAttribute

- 用于修饰方法，该方法会在Controller方法执行前被调用，用于为Model对象绑定参数。

####### @DataBinder

- 用于修饰方法，该方法会在Controller方法执行前被调用，用于绑定参数的转换器。

##### 统一日志处理

###### AOP 示例

```
@Component
@Aspect
public class AlphaAspect {

    @Pointcut("execution(* com.nowcoder.community.service.*.*(..))")
    public void pointcut() {

    }

    @Before("pointcut()")
    public void before() {
        System.out.println("before");
    }

    @After("pointcut()")
    public void after() {
        System.out.println("after");
    }

    @AfterReturning("pointcut()")
    public void afterReturning() {
        System.out.println("afterReturning");
    }

    @AfterThrowing("pointcut()")
    public void afterThrowing() {
        System.out.println("afterThrowing");
    }

    @Around("pointcut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("around before");
        Object obj = joinPoint.proceed();
        System.out.println("around after");
        return obj;
    }
}

```

###### 使用 AOP 实现统一日志管理

```
@Component
@Aspect
public class ServiceLogAspect {

    private static final Logger logger = LoggerFactory.getLogger(ServiceLogAspect.class);

    @Pointcut("execution(* com.nowcoder.community.service.*.*(..))")
    public void pointcut() {

    }

    @Before("pointcut()")
    public void before(JoinPoint joinPoint) {
        // 用户[1.2.3.4]，在[xxx]，访问了[com.nowcoder.community.service.xxx()]。
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = attributes.getRequest();
        String ip = request.getRemoteHost();
        String now = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
        String target = joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName();
        logger.info(String.format("用户[%s]，在[%s]，访问了[%s]。", ip, now, target));
    }
}
```

#### Redis

##### Spring整合Redis

###### 引入依赖

####### spring-boot-starter-data-redis  

###### 配置Redis

####### 配置数据库参数

```
# RedisProperties
spring.redis.database=11
spring.redis.host=localhost
spring.redis.port=6379
```

####### 编写配置类，构造RedisTemplate

```
// 设置key的序列化方式
template.setKeySerializer(RedisSerializer.string());
// 设置value的序列化方式
template.setValueSerializer(RedisSerializer.json());
// 设置hash的key的序列化方式
template.setHashKeySerializer(RedisSerializer.string());
// 设置hash的value的序列化方式
template.setHashValueSerializer(RedisSerializer.json());
```

######## spring-redis 默认使用了 jdk 自带的序列化, 通过泛型的 K 和 V 设置键值对的对象类型

######## 重新定义序列化，令键为 String，值为 Object，使用 json 格式保存 Object。

##### 点赞


某个实体的赞
```
like::entity:entityType:entityId -> set(userId) 
```
用set而不用String统计赞的原因是：方便以后查询谁给你点赞


###### 进行点赞

```
/* LikeService.java */
// 点赞
public void like(int userId, int entityType, int entityId) {
	String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
    // 查询是否已赞过
	boolean isMember = redisTemplate.opsForSet().isMember(entityLikeKey, userId);
	if (isMember) {
    	// 已赞过则取消点赞
		redisTemplate.opsForSet().remove(entityLikeKey, userId);
	} else {
    	// 未赞过则进行点赞
		redisTemplate.opsForSet().add(entityLikeKey, userId);
	}
}
```

###### 查询点赞数量

```
/* LikeService.java */
// 查询某实体点赞的数量
public long findEntityLikeCount(int entityType, int entityId) {
	String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
	return redisTemplate.opsForSet().size(entityLikeKey);
}
```

###### 查询点赞状态

```
/* LikeService.java */
// 查询某人对某实体的点赞状态
public int findEntityLikeStatus(int userId, int entityType, int entityId) {
	String entityLikekey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
	return redisTemplate.opsForSet().isMember(entityLikekey, userId) ? 1 : 0;
}
```

####### 未登录时不显示点赞状态

```
// 点赞状态
int likeStatus = hostHolder.getUser() == null ? 0 :
		likeService.findEntityLikeStatus(hostHolder.getUser().getId(), 
        ENTITY_TYPE_POST, discussPostId);
model.addAttribute("likeStatus", likeStatus);
```

##### 我收到的赞

某个用户已获得的赞
```
like:user:userId -> int
```

###### 重构点赞，用事务绑定点赞和我收到的赞

```
/* LikeService.java */
public void like(int userId, int entityType, int entityId, int entityUserId) {
	redisTemplate.execute(new SessionCallback() {
		@Override
		public Object execute(RedisOperations operations) throws DataAccessException {
			String entityLikeKey = RedisKeyUtil.getEntityLikeKey(entityType, entityId);
			String userLikeKey = RedisKeyUtil.getUserLikeKey(entityUserId);
            // 查询是否已赞过
			boolean isMember = operations.opsForSet().isMember(entityLikeKey, userId);

			operations.multi();

			if (isMember) {
            	// 已赞过则取消点赞
				operations.opsForSet().remove(entityLikeKey, userId);
				operations.opsForValue().decrement(userLikeKey);
			} else {
            	// 未赞过则进行点赞
				operations.opsForSet().add(entityLikeKey, userId);
				operations.opsForValue().increment(userLikeKey);
			}

			return operations.exec();
		}
	});
}
```

###### 查询某个用户获得的赞的数量

```
/* LikeService.java */
// 查询某个用户获得的赞
public int findUserLikeCount(int userId) {
	String userLikeKey = RedisKeyUtil.getUserLikeKey(userId);
	Integer count = (Integer) redisTemplate.opsForValue().get(userLikeKey);
	return count == null ? 0 : count.intValue();
}
```

##### 关注、取消关注

某个用户关注的实体
``` 
followee:userId:entityType -> zset(entityId, now)
```

某个实体拥有的粉丝
```
follower:entityType:entityId -> zset(userId, now)
```

###### 事务实现关注

```
public void follow(int userId, int entityType, int entityId) {
	redisTemplate.execute(new SessionCallback() {
		@Override
		public Object execute(RedisOperations operations) throws DataAccessException {
        	// 绑定用户关注的实体类型
			String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
            // 绑定被关注的实体及其类型
			String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);

			operations.multi();

			// 添加用户关注的实体
            operations.opsForZSet().add(followeeKey, entityId, System.currentTimeMillis());
			// 添加实体被关注的粉丝
            operations.opsForZSet().add(followerKey, userId, System.currentTimeMillis());

			return operations.exec();
		}
	});
}
```

###### 事务取消关注

```
public void unfollow(int userId, int entityType, int entityId) {
	redisTemplate.execute(new SessionCallback() {
		@Override
		public Object execute(RedisOperations operations) throws DataAccessException {
			String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
			String followerKey = RedisKeyUtil.getFollowerKey(entityType, entityId);

			operations.multi();

			operations.opsForZSet().remove(followeeKey, entityId);
			operations.opsForZSet().remove(followerKey, userId);

			return operations.exec();
		}
	});
}
```

###### 查询关注的实体数

```
// 查询关注的实体的数量
public long findFolloweeCount(int userId, int entityType) {
	String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
	return redisTemplate.opsForZSet().zCard(followeeKey);
}
```

###### 查询实体的粉丝数

```
// 查询关注的实体的数量
public long findFolloweeCount(int userId, int entityType) {
String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
return redisTemplate.opsForZSet().zCard(followeeKey);
}
```


###### 查询当前用户是否已关注该实体

```
// 查询当前用户是否已关注该实体
public boolean hasFollowed(int userId, int entityType, int entityId) {
	String followeeKey = RedisKeyUtil.getFolloweeKey(userId, entityType);
	return redisTemplate.opsForZSet().score(followeeKey, entityId) != null;
}
```

##### 关注列表、粉丝列表

###### 查询用户关注的人

```
// 查询某用户关注的人
public List<Map<String, Object>> findFollowees(int userId, int offset, int limit) {
	String followeeKey = RedisKeyUtil.getFolloweeKey(userId, ENTITY_TYPE_USER);
	Set<Integer> targetIds = redisTemplate.opsForZSet().reverseRange(
    	followeeKey, offset, offset + limit - 1);

	if (targetIds == null) {
		return null;
	}

	List<Map<String, Object>> list = new ArrayList<>();
	for (Integer targetId : targetIds) {
		Map<String, Object> map = new HashMap<>();
		User user = userService.findUserById(targetId);
		map.put("user", user);
		Double score = redisTemplate.opsForZSet().score(followeeKey, targetId);
		map.put("followTime", new Date(score.longValue()));
		list.add(map);
	}

	return list;
}
```

###### 查询用户的粉丝

```
// 查询某用户的粉丝
public List<Map<String, Object>> findFollowers(int userId, int offset, int limit) {
	String followerKey = RedisKeyUtil.getFollowerKey(userId, ENTITY_TYPE_USER);
	Set<Integer> targetIds = redisTemplate.opsForZSet().reverseRange(
    	followerKey, offset, offset + limit - 1);

	if (targetIds == null) {
		return null;
	}

	List<Map<String, Object>> list = new ArrayList<>();
	for (Integer targetId : targetIds) {
		Map<String, Object> map = new HashMap<>();
		User user = userService.findUserById(targetId);
		map.put("user", user);
		Double score = redisTemplate.opsForZSet().score(followerKey, targetId);
		map.put("followTime", new Date(score.longValue()));
		list.add(map);
	}

	return list;
}
```

##### 优化登录模块

###### Redis 存储验证码

```
@RequestMapping(path = "/kaptcha", method = RequestMethod.GET)
public void getKaptcha(HttpServletResponse response) {
    // 生成验证码
    String text = kaptchaProducer.createText();
    BufferedImage image = kaptchaProducer.createImage(text);

    // 相当于模拟 Session 的过程，生成 SessionId 存入 Cookie
    String kaptchaOwner = CommunityUtil.generateUUID();
    Cookie cookie = new Cookie("kaptchaOwner", kaptchaOwner);
    cookie.setMaxAge(60);
    cookie.setPath(contextPath);
    response.addCookie(cookie);

    // 将验证码存入Redis
    String redisKey = RedisKeyUtil.getKaptchaKey(kaptchaOwner);
    redisTemplate.opsForValue().set(redisKey, text, 60, TimeUnit.SECONDS);
}
```

####### 验证码需要频繁的访问与刷新，对性能要求较高

####### 验证码不需永久保存，通常在很短的时间后就会失效

####### 分布式部署时，存在Session共享的问题

###### Redis存储登录凭证

####### 登录时生成登录凭证

```
public Map<String, Object> login(String username, String password, int expiredSeconds) {
	Map<String, Object> map = new HashMap<>();
    ...
    
    // 生成登录凭证
    LoginTicket loginTicket = new LoginTicket();
    loginTicket.setUserId(user.getId());
    loginTicket.setTicket(CommunityUtil.generateUUID());
    loginTicket.setStatus(0);
    loginTicket.setExpired(new Date(System.currentTimeMillis() + expiredSeconds * 1000));

    // 将凭证存入Redis
    String redisKey = RedisKeyUtil.getTicketKey(loginTicket.getTicket());
    redisTemplate.opsForValue().set(redisKey, loginTicket);

    map.put("ticket", loginTicket.getTicket());
    return map;
}
```

######## 将 ticket 存入 Cookie 发给客户端

```
@RequestMapping(path = "/login", method = RequestMethod.POST)
public String login(String username, String password, String code, boolean rememberme,
					Model model, HttpServletResponse response,
					@CookieValue("kaptchaOwner") String kaptchaOwner) {
	// 检测验证码
	...

	// 检查账号，密码
	int expiredSecondes = rememberme ? REMEMBER_EXPIRED_SECONDS : DEFAULT_EXPIRED_SECONDS;
	Map<String, Object> map = userService.login(username, password, expiredSecondes);
	if (map.containsKey("ticket")) {
    
    	// 将ticket存入Cookie发给客户端
		Cookie cookie = new Cookie("ticket", map.get("ticket").toString());
		cookie.setPath(contextPath);
		cookie.setMaxAge(expiredSecondes);
		response.addCookie(cookie);
        
		// 登录成功重定向到首页
		return "redirect:/index";
	} else {
		model.addAttribute("usernameMsg", map.get("usernameMsg"));
		model.addAttribute("passwordMsg", map.get("passwordMsg"));
		return "/site/login";
	}
}
```

####### 登录中查询登录凭证

```
public LoginTicket findLoginTicket (String ticket) {
	String redisKey = RedisKeyUtil.getTicketKey(ticket);
	return (LoginTicket) redisTemplate.opsForValue().get(redisKey);
}
```

######## 拦截器查询凭证

```
// 浏览器向服务器发出请求时，服务器创建一个线程来处理请求，当服务器发出响应后，该线程才被销毁。
@Component
public class LoginTicketInterceptor implements HandlerInterceptor {
    @Autowired
    private UserService userService;

    @Autowired
    private HostHolder hostHolder;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 从Cookie中获取凭证
        String ticket = CookieUtil.getValue(request, "ticket");

        if (ticket != null) {
            // Redis中查询凭证
            LoginTicket loginTicket = userService.findLoginTicket(ticket);
            // 检查凭证是否有效
            if (loginTicket != null && loginTicket.getStatus() == 0 
            	&& loginTicket.getExpired().after(new Date())) {
                // 根据凭证查询用户
                User user = userService.findUserById(loginTicket.getUserId());
                // 在本次请求中持有用户
                hostHolder.setUser(user);
            }
        }

        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, 
    ModelAndView modelAndView) throws Exception {
        User user = hostHolder.getUser();
        if (user != null && modelAndView != null) {
            modelAndView.addObject("loginUser", user);
        }
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
    Object handler, Exception ex) throws Exception {
        hostHolder.clear();
    }
}
```

####### 登出时更改凭证状态

```
public void logout(String ticket) {
	String redisKey = RedisKeyUtil.getTicketKey(ticket);
	LoginTicket loginTicket = (LoginTicket) redisTemplate.opsForValue().get(redisKey);
	loginTicket.setStatus(1);
	redisTemplate.opsForValue().set(redisKey, loginTicket);
}
```

###### Redis缓存用户信息

####### 优先从缓存中取值，取不到时初始化数据 

```
public User findUserById (int id) {
	User user = getCache(id);
    if (user == null) {
	    user = initCache(id);
    }
    return user;
}

// 1.优先从缓存中取值
private User getCache(int userId) {
	String redisKey = RedisKeyUtil.getUserKey(userId);
	return (User) redisTemplate.opsForValue().get(redisKey);
}

// 2.取不到时初始化缓存数据
private User initCache(int userId) {
	User user = userMapper.selectById(userId);
	String redisKey = RedisKeyUtil.getUserKey(userId);
	redisTemplate.opsForValue().set(redisKey, user, 3600, TimeUnit.SECONDS);
	return user;
}
```

####### 数据变更时清除缓存资源

```
// 3.数据变更时清除缓存资源
private void clearCache(int userId) {
	String redisKey = RedisKeyUtil.getUserKey(userId);
	redisTemplate.delete(redisKey);
}
```

## 中间件

### RabbitMQ

### ZooKeeper

### Dubbo

### Nginx
