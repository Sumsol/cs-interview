# 技术面试复习大纲

<!--Note-->
## 资料 

- [CS-Notes](https://cyc2018.github.io/CS-Notes/#/)
- [后端面试进阶指南](https://xiaozhuanlan.com/topic/2167809435)

## 协议

分享或者修改演绎时请保留本协议，并署名  [@CyC2018](https://dwz.cn/ZGWCOICD)。

[CC BY - Creative Commons Attribution](http://creativecommons.org/licenses/by-nc-sa/4.0)

![](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)
<!--/Note-->

## README

<!--Note-->
### 协议

分享或者修改演绎时请保留本协议，并署名  [@CyC2018](https://dwz.cn/ZGWCOICD)。

[CC BY - Creative Commons Attribution](http://creativecommons.org/licenses/by-nc-sa/4.0)

![](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)

### 目的

方便大家系统梳理知识点，并且针对每个知识点可以在本脑图中写 Markdown 笔记。

每个知识点也有相应的完成度和优先级，对于不同重要程度的知识点应该采取不同的复习方法，从而提高学习效率。

你应该把这个脑图当做最基本的复习材料，每天都要大概地过一遍，保持短期记忆，一定要知道，短期记忆对面试来说至关重要。

也可以将收集的资料整理在本脑图中，从而方便复习。

### 来源

[知识总结方法](https://xiaozhuanlan.com/topic/4150387926)

### 关于我

https://dwz.cn/ZGWCOICD

### 样式修改

百度脑图自带的样式效果不佳，建议安装以下样式脚本：[百度脑图](https://userstyles.org/styles/163774/theme)。

### 保存方法

点击左上角菜单，然后另存为“我的文档”。




<!--/Note-->

## 数据结构与算法

<!--Note-->
### 资料

- [剑指 Offer 题解](https://cyc2018.github.io/CS-Notes/#/notes/剑指%20offer%20题解)
- [Leetcode 题解](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20题解)
- [算法](https://cyc2018.github.io/CS-Notes/#/notes/算法)
- 《算法》
- 《剑指 Offer》
- 《程序员代码面试指南》
- 《挑战程序设计竞赛》
- [Leetcode](https://leetcode.com/problemset/algorithms/)
- [玩转算法面试 从真题到思维全面提升算法思维](https://coding.imooc.com/class/82.html)
<!--/Note-->

### 排序

<!--Note-->
##### 1.排序算法的比较

算法|稳定性|时间复杂度|空间复杂度|备注
:-:|:-:|:-:|:-:|:-:
选择排序|×|N²|1|运行时间与输入无关，数据移动最少|
冒泡排序|√|N²|1||
插入排序|√|N~N²|1|时间复杂度和初始顺序有关|
希尔排序|×|	N 的若干倍乘于递增序列的长度|logN|改进版插入排序|
快速排序|×|NlogN|logN|运行效率由概率提供保证|
三向切分快速排序|×|N~NlogN|logN|适用于有大量重复主键|
归并排序|√|NlogN|N||
堆排序|×|NlogN|1|无法利用局部性原理|





<!--/Note-->

#### 冒泡排序

<!--Note-->
##### 冒泡排序

从左到右不断交换相邻逆序的元素，让未排序的最大元素上浮到右侧。

```
public class Bubble{
	public void sort(int[] a) {
		int N = a.length;
		for (int i = N - 1; i > 0; i--) { 
			for (int j = 0; j < i; j++) {
				if (a[j+1] < a[j]) {
                	swap(a, j, j+1);
                }
            }
        }
	}
}
```
<!--/Note-->

#### 归并排序

##### 归并方法 

```
	private void merge(int[] a, int lo, int mid, int hi) {
		int i = lo, j = mid + 1;
		
		for (int k = lo; k <= hi; k++)
			aux[k] = a[k];
		
		for (int k = l; k <= hi; k++) {
			if (i > mid) {
            	a[k] = aux[j++];
			} else if (j > hi) { 
            	a[k] = aux[i++];
			} else if (aux[j] < aux[i]) { 
            	a[k] = aux[j++];
			} else { 
            	a[k] = aux[i++]; // 保证稳定性
			}
        }	
	}
```

##### 自顶向下归并排序 

- 1/2NlgN 至 NlgN 次比较。最多访问数组 6NlgN。

```
public class UptoDownMerge{
	public void sort(int[] a) {
		aux = new int[a.length]; 
		sort(a, 0, a.length-1);
	}
	
	public void sort(int[] a, int lo, int hi) {
		if (hi <= lo) return;
		int mid = lo + (hi - lo) / 2;
		sort(a, lo, mid);
		sort(a, mid+1, hi);
		merge(a, lo, mid, hi);
	}
}
```

##### 自底向上归并排序 

- 1/2NlgN 至 NlgN 次比较。最多访问数组 6NlgN 。

```
public class DowntoUpMerge {
	public void sort(int[] a) {
		int N = a.length;
		aux = new int[N];
		for(int len = 1; len < N; len *= 2) {
        	int sz = len + len;
			for(int lo = 0; lo < N - len; lo += sz) {
				merge(a, lo, lo + len - 1, Math.min(lo + sz - 1, N -  1));
			}
		}
	}
}
```

#### 快速排序

##### 切分

```
private int partition(int[] a, int lo, int hi) {
	int i = lo, j = hi + 1;
    int v = a[lo];
    while (true) {
    	while (a[++i] < v && i != hi); 
    	while (a[--j] > v && j != lo);
    	if (i >= j) break;
    	swap(a, i, j);
    }
    swap(a, lo, j);
    return j;
}
```

##### 快速排序

- 快速排序是原地排序，使用的空间是`O(1)`，但真正消耗空间的
是递归调用，平均空间复杂度为`O(logn)`。

```
public class QuickSort{
	public void sort(int[] a) {
		shuffle(a);
		sort(a, 0, a.length - 1);
	}
	
	private void sort(int[] a, int lo, int hi) {
		if (hi <= lo) return;
		int j = partition(a, lo, hi);
		sort(a, lo, j-1);
		sort(a, j+1, hi);
	}
	
	private void shuffle(int[] a) {
		List<Comparable> list = Arrays.asList(a);
		Collections.shuffle(list);
		list.toArray(a);
	}
}
```

##### 三向切分排序

- 对于包含**大量重复元素**的数组，它将排序时间从线性对数级降低到线性级别。
- 需要 *~(2ln2)NH* 次比较。其中 *H* 为由主键值出现频率定义的香农信息量。

```
public class ThreeWayQuickSort {
    public void sort(int[] nums, int l, int h) {
        if (h <= l) {
            return;
        }
        int lt = l, i = l + 1, gt = h;
        int v = nums[l];
        while (i <= gt) {
            if (nums[i] < v) {
                swap(nums, lt++, i++);
            } else if (nums[i] > v) {
                swap(nums, i, gt--);
            } else {
                i++;
            }
        }
        sort(nums, l, lt - 1);
        sort(nums, gt + 1, h);
    }
}

```

##### 快速选择

- 时间复杂度为 *O(N)*，假设每次能将数组二分，那么比较的总次数为 `(N+N/2+N/4+..)`，直到找到第 `k` 个元素，这个和显然小于 `2N`。

```
public class QuickSelect{
	public int select(int a[], int k) {
		int lo = 0, hi = a.length - 1;
		while (hi > 1) {
			int j = partition(a, lo, hi);
			if (k == j) return a[k];
			else if (k < j) hi = j - 1;
			else lo = j + 1;
		}
		return a[k];
	}
}
```


## 操作系统

<!--Note-->
### 资料

- 《现代操作系统》
- 《深入理解计算机系统》
- 《UNIX 环境高级编程》
- 《Unix/Linux 编程实践教程》
- 《鸟哥的 Linux 私房菜》
- 《The Linux Command Line》
<!--/Note-->

### 基础

#### 进程调度算法

##### 先来先服务 first-come first-served (FCFS)

最简单的非抢占式调度算法，进程按照它们请求CPU的顺序使用CPU。如果进程在执行中被阻塞，就绪队列中的第一个会得到CPU。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

##### 最短作业优先 shortest job first (SJF)

适用于运行时间可预知的非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

######  

##### 最短剩余时间优先 shortest remaining time next(SRTN)

最短作业优先的抢占式版本。调度程序总是选择剩余运行时间最短的那个进程运行。

##### 轮转调度

将所有就绪进程按 FCFS 的原则排成一个队列，每个进程被分配一个时间片。当队首进程时间片用完时，将它移至就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转调度的效率和时间片的大小有很大关系：
- 时间片设得太短会导致过多的进程切换，降低CPU效率；
- 而设得太长又可能引起对短的交互请求的响应时间变长。
- 将时间片设为20~50ms通常是一个比较合理的折中。

######  

##### 优先级调度

每个进程被赋予一个优先级，允许优先级最高的可执行程序先执行。

- 为了防止高优先级进程无休止地运行下去，调度程序可能在每个时钟中断降低当前进程的优先级。
- 优先级可以是静态赋予或动态赋予。
- 可以将一组进程按优先级分为若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。

######  

##### 多级队列

属于最高优先级类的进程运行1个时间片，属于次高优先级类的进程运行2个时间片，再次一级运行4个时间片，以此类推。当一个进程用完分配的时间片后，它被移动下一类。那么一个进程被分配的时间片依次是1、2、4、8、16...

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

######  

#### 进程间通信IPC

<!--Note-->
####### 通讯方式总结

1.管道：速度慢，容量有限，只有父子进程能通讯    

2.FIFO：任何进程间都能通讯，但速度慢    

3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    

4.信号量：不能传递复杂消息，只能用来同步    

5.共享内存区：能够很容易控制容量，速度快，但要保持同步
————————————————
https://blog.csdn.net/wh_sjc/article/details/70283843


<!--/Note-->

##### 管道

管道，通常指无名管道。

- 只支持*半双工通信*（单向交替传输）；
- 只能在*父子进程*或者*兄弟进程*中使用；
- 是一种特殊文件，只*存在于内存中*。


##### FIFO

FIFO，也称为*命名管道*，它是一种文件类型。

- 可用于*无关进程*交换数据，与无名管道不同。

- 以一种特殊设备文件存*在于文件系统中*。

- FIFO的通信方式类似于在进程中*使用文件来传输数据*，只不过FIFO类型文件同时*具有管道的特性(半双工）*。在数据读出时，FIFO管道中同时清除数据，并且“*先进先出*”。常用于客户-服务器应用程序中。


##### 消息队列

消息队列，是消息的链接表，*存放在内核中*。

### 特点
- *避免*了 FIFO 的*同步阻塞*问题，不需要进程自己提供同步方法

- 消息队列*独立于读写进程*。进程终止时，消息队列及其内容不会被删除。

- 消息队列可实现*消息随机查询*，可按消息类型读取，不像FIFO以先进先出次序读取。


##### 信号量

信号量（semaphore）是一个计数器，用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

### 特点
- 信号量*用于进程间同步*，若要在进程间传递数据需要结合共享内存。

- 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。

- 每次对信号量的 PV 操作不仅限于加 1 或减 1，可加减任意正整数。

- 支持信号量组。

##### 共享内存

共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。
### 特点
- 共享内存是*最快*的一种 IPC，因为进程是直接对内存进行存取。

- 因为多个进程可以同时操作，所以*需要进行同步*。

- *信号量 + 共享内存*通常结合在一起使用，信号量用来同步对共享内存的访问。

##### socket套接字

与其它通信机制不同的是，它可用于*不同机器间的进程通信*。

#### 页面置换算法

PS:特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。

当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

## 页面置换算法小结
算 法 |注 释
------|------
最优算法 | 不可实现，但可用作基准
NRU（最近未使用）算法 | LRU的很粗糙的近似
FIFO（先进先出）算法 | 可能抛弃重要页面
第二次机会算法 | 比FIFO有较大的改善
时钟算法 | 现实的
LRU (最近最少使用）算法 | 很优秀，但很难实现
NFU (最不经常使用）箕法 | LRU的相对粗略的近似
老化算法 | 非常近似LRU的有效算法
工作集算法 | 实现起来开销很大
工作集时钟算法 | 好的有效算法

##### 最优（OPT, Optimal replacement algorithm）

标记每个页面被访问前所要执行的指令数，最优页面置换算法规定应该置换标记最大的页面。

该算法无法实现，是一种理论上的算法，因为操作系统无法知道各个页面下一次将在什么时候被访问。

可以通过仿真程序运行时收集的信息实现最优页面置换算法，以用来与其他可实现算法的性能进行比较。

##### 先进先出（FIFO, First-In First-Out）

由操作系统维护一个当前在内存中的所有页面的链表，最新进入的页面在尾部，最早进入的放在表头，每当发生缺页中断，就替换掉表头的页面并且把新调入的页面加入到链表末尾。

该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

##### 最近未使用（NUR, Not Recently Used）

每个页面都有两个状态位：R 与 M，当页面被访问时设置 R 位，当页面被修改时设置 M 位。其中 R 位会定时被清零。可以将页面分成以下四类：

- 第0类：没有被访问，没有被修改。
- 第1类：没有被访问，已被修改。
- 第2类：已被访问，没有被修改。
- 第3类：已被访问，已被修改。

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的页面（R=0，M=1），而不是被频繁使用的“干净”页面（R=1，M=0）。

NRU 的主要优点是易于理解和能够有效地被实现，虽然性能不是最好的，但是够用。

##### 第二次机会（second chance）

针对FIFO算法可能将经常使用的页面置换出去，因此检查最老页面的R位。若R=0，立刻置换掉；若R=1，将R位清0并将该页面放到链表尾部。

######  

##### 时钟（clock）

第二次算法经常在链表中移动页面，降低了效率。时钟算法把所有页面都保存在一个类似钟面的环形链表中，一个表针指向最老页面。

######  

##### 最近最少使用（LRU, Least Recently Used）

在缺页中断发生时，置换未使用时间最长的页面，称为LRU。

LRU是可实现的，需要在内存中维护一个所有页面的链表，最近最多使用的放表头，最近最少使用的放表尾，每次访问内存时都需更新链表，代价较大。

很少有计算机能使用硬件实现LRU算法，因此需要能用软件实现的方法。NFU（Not Frequently Used，最不常用）算法将每个页面与一个软件计数器相关联，每次时钟中断时，扫描每个页面的R位并加到其计数器上，从而跟踪各个页面被访问的频率。

NFU存在的问题是很久之前的一次使用，与最近的使用权重相等。老化（aging）算法对其进行了改进：在R位加进之前将计数器右移一位，然后加到计数器的最左端的位。老化算法的计数器只能有限位数，因此限制了对以往页面的记录。

######  

##### 工作集算法（WSClock）

简单来说，工作集就是在最近k次内存访问所使用过的页面的集合。原始的工作集算法同样代价很大，对它进行简化：在过去Nms的内存访问中所用到的页面的集合。

所以，在实现的时候，可以给每个页面一个计时器。需要置换页面时，同实际时间进行对比，R为1，更新到现在时间；R为0，在规定阈值之外的页面可以被置换。

同样，这个算法也可以用时钟的思想进行改进。

#### 磁盘调度算法

读写磁盘块所需时间的决定因素：

- 1）寻道时间（将磁盘臂移动到适当的柱面上所需的时间）。
- 2）旋转延迟（等待适当扇区旋转到磁头下所需的时间）。
- 3）实际数据传输时间。

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

##### 先来先服务（First-Come, First-Served, FCFS）

定义：磁盘驱动程序每次接受一个请求并按照接受顺序完成请求。

优点是简单和公平。缺点是很难优化寻道时间，磁头移动的距离和平均距离可能很大。

##### 最短寻道优先（Shortest Seek First，SSF）

定义：下一次总是处理与磁头距离最近的请求以使寻道时间最小化。

虽然得到最小响应时间，但缺乏公平性。当磁盘负载很重时，可能会使磁头一直停留在磁盘某区域，远离该区域的请求很难得到响应，直至该区域无请求为止。

##### 电梯算法（SCAN）

定义：与电梯运行一样，保持按一个方向移动，直到那个方向上没有请求为止，然后才改变方向。

电梯算法的一个优点是，对任意一组请求，磁盘臂移动总次数上界均为柱面数的两倍。

##### 循环扫描算法（SCAN）

定义：总是按一个方向扫描，当处理完请求的最高编号柱面后，立即回到未完成请求的最低编号柱面，然后继续沿该方向移动。

该方法相对于电梯算法在响应时间上具有更小的变异。

### Linux

#### 常用命令

- 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。

## 网络

<!--Note-->
### 资料

- 《计算机网络 自顶向下方法》
- 《计算机网络》
- 《TCP/IP 详解 卷 1：协议》
- 《UNIX 网络编程 卷 1：套接字联网 API》
- 《Linux 多线程服务端编程》
- 《图解 HTTP》
<!--/Note-->

### 基础

- [计算机网络](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络)

#### UDP 与 TCP

##### 传输控制协议TCP

###### 面向连接、可靠交付、面向字节流、点对点

###### 首部格式

- 源端口和目的端口——各占2字节。端口是应用层与传输层的服务接口。
- 序号——占4字节。TCP连接传输的数据流中的每一个字节都会被编上一个序号。而这里的序号字段指的是发送的数据段中第一个字节的序号。
- 确认号——占4字节。是期望收到对方下一次发来的序号字段的值。
- 数据偏移——占4bit。指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- 确认ACK——当ACK=1时确认号（第三行的） 有效，当ACK=0时确认号无效。
- 同步SYN——当SYN=1时，表明这是一个连接请求或者连接接受报文。
- 终止FIN——当FYN=1时，表明此报文段的发送方的数据已发送完毕，并且要求释放连接。
- 窗口字段——占2字节。包含滑动窗口和拥塞窗口，后面详解。
- 校验和——占2字节。包括首部校验和数据校验两部分。在计算校验和的时候要在TCP报文段前面加上12字节的伪首部。

#######  

###### 文件传输、发送和接收邮件、远程登录等场景。

##### 用户数据报协议UDP

###### 无连接、尽最大可能交付、面向报文、广播或多播

###### 首部格式

端口：是应用层和传输层的服务接口
UDP长度：首部 + 数据总长度
UDP校验和：伪首部、首部、数据 三部分的校验和
伪首部：它并不是在UDP数据报中存在的有效数据，也不会被发送，它的存在仅是为了计算校验和，所以叫做伪首部。它是提取了源IP地址、目的IP地址等字段构造的数据。

#######  

###### QQ 语音、 QQ 视频 、直播等等

#####  

#### TCP 可靠传输

- 设计可靠 UDP 协议

##### 确认号 + 序号

###### TCP给发送的每一个包进行编号，接收方对接收的数据进行按序确认，把有序数据传送给应用层。

##### 校验和

###### 发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。

##### 超时重传

###### 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

##### 流量控制

###### 滑动窗口

#######  

###### 流量控制

####### 控制发送方速率，使接收方来得及接收

####### 发送窗口 <= 接收窗口

##### 拥塞控制

### HTTP

- [HTTP](https://cyc2018.github.io/CS-Notes/#/notes/HTTP)

#### GET 与 POST

##### 作用

###### GET获取资源

###### POST传输实体主体

##### 参数

###### 存储

####### GET参数出现在URL中，URL只支持ASCII码，中文等参数需要编码。

####### POST参数存储在实体主体中，支持标准字符集。

###### 数据大小

####### GET受URL长度限制

####### POST不受限制

###### 安全

####### 安全方法

不修改服务器的数据


######## 安全: GET, HEAD, OPTIONS

######## 不安全: POST, PUT, DELETE

####### 数据安全性

######## POST的安全性比GET高

##### 幂等性

幂等的HTTP方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。

###### 幂等：GET, HEAD, PUT, DELETE

###### 不幂等：POST

##### 可缓存

###### GET、HEAD可缓存

###### POST多数情况不可缓存，PUT、DELETE不可缓存

#### 状态码

##### 1XX 信息

###### 100 Continue

####### 目前为止都正常，继续

##### 2XX 成功

###### 200 OK

###### 204 No Content

####### 返回响应报文不含实体主体

###### 206 Partial Content

####### 响应范围请求成功

##### 3XX 重定向

###### 301 Moved Permanently

####### 请求资源已永久移到新位置

###### 302 Found

####### 请求资源临时从不同URI响应

###### 303 See Other

####### 同302，但要求GET方法

###### 304 Not Modified

####### 带条件的请求被允许，但资源未改变

###### 307 Temporary Redirect

####### 同302，但禁止POST改成GET

##### 4XX 客户端错误

###### 400 Bad Request

####### 请求报文中存在语法错误

###### 401 Unauthorized

####### 请求需要用户认证或认证失败

###### 403 Forbidden

####### 请求被拒绝

###### 404 Not Found

##### 5XX 服务器错误

###### 500 Internal Server Error

####### 服务器执行请求时发生错误

###### 503 Service Unavailable

####### 服务器暂处于超负荷或停机维护

#### HTTP1.1新特性 

##### 默认长连接，支持流水线

##### 新增更多的缓存控制策略

###### max-age，If-Match, If-None-Match

##### 新增多个状态响应码

###### 100

##### 新增Host头字段，支持虚拟主机

一台服务器多个域名

##### 新增range头字段，支持断点续传

#### HTTPS

让HTTP先与SSL通信，再由SSL和TCP通信，即使用隧道通信。

##### 与HTTP对比

###### HTTP

####### 明文通信，可被窃听

####### 不验证通信方身份，可被伪装

####### 无法证明报文完整性，可被篡改

###### HTTPS

####### 因为需要加密和解密，速度更慢

####### 需要支付证书授权的高额费用

##### 对称加密算法

###### DES

Data Encryption Standard

###### 3DES

####### 对 一块数据 用 三个不同的密钥 进行 三次加密，强度更高。

###### AES

Advanced Encryption Standard

####### 比 DES 更 安全性、效率 和 灵活性

##### 非对称加密算法

###### RSA

###### ECC

####### 比RSA相当的或更高等级 的安全级别

##### 消息摘要算法

使用哈希函数，产生信息摘要，防篡改

###### MD5

MD5 Message-Digest Algorithm

###### SHA1

Secure Hash Algorithm 1

####### 比MD5安全性更强

###### HMAC

Hash-based Message Authentication Code

####### 输入密钥和消息，输出消息摘要

#### HTTP/2

##### 二进制分帧层

###### 报文分HEADERS帧和DATA帧，都用二进制编码

###### 通信只用一个TCP连接，承载任意数量双向数据流（Stream）

##### 多路复用

###### 解决了HTTP1.x的队首阻塞问题，数据分解为帧发送，根据帧头中流标识符重新组装

##### 服务器推送

###### 客户端请求一个资源，会自动将相关资源一起发送

##### 首部压缩

###### 维护和更新一个首部字段表，避免传输重复字段，并编码进行压缩 

### Socket

- [Socket](https://cyc2018.github.io/CS-Notes/#/notes/Socket)

#### I/O 模型

##### 阻塞式I/O

###### 1、2阶段都阻塞，CPU利用率高

#######  

##### 非阻塞式I/O

###### 1阶段轮询，2阶段阻塞，CPU利用率低

#######  

##### I/O复用

###### 1阶段阻塞在select，2阶段阻塞，多连接时开销小

#######  

##### 信号驱动I/O

###### 1阶段非阻塞，2阶段阻塞，CPU利用率高

#######  

##### 异步I/O

###### 1、2阶段都非阻塞

#######  

## 数据库

<!--Note-->
### 资料

- 《MySQL 必知必会》
- [Leetcode](https://leetcode.com/problemset/database/)
- 《高性能 MySQL》
- 《MySQL 技术内幕》
- 《Redis 设计与实现》
- 《Redis 实战》
- 《大规模分布式存储系统》
<!--/Note-->

### MySQL

#### 事务

##### ACID

###### 原子性（atomicity）

事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。

如果事务没能完成它的执行，数据库系统从日志中恢复旧值，使得看上去事务从未执行过。

###### 一致性（consistency）

如果一个事务作为原子从一个一致的数据库状态开始独立地执行，则事务结束时数据库也必须再次是一致的。

例如，一致性要求转账过程中事务的执行A账户、B账户之和不变。

###### 隔离性（isolation）

数据库必行采取特殊处理来确保事务正常执行而不被来自并发执行的数据库语句所干扰。

事务的隔离性确保事务并发执行后的系统状态和这些事务以某种次序一个接一个地执行后的状态是等价的。

###### 持久性（durability）

一个事务完成后，它对数据库的改变必须是永久的，即使出现系统故障。

确保事务做的更新在事务结束前已经写入磁盘或有关事务已执行的更新信息已写到磁盘上。

######  

#######  

##### 隔离级别

四大隔离级别，以及不可重复读和幻影读的出现原因。

###### 未提交读（read uncommitted）

解决更新丢失问题。如果一个事务已经开始写操作，那么其他事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现，即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据不需要加 S 锁。

####### 解决更新丢失

####### 排他锁实现

###### 已提交读（read committed）

解决了脏读问题。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。这可以通过“瞬间共享读锁”和“排他写锁”实现， 即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事务结束。

####### 解决脏读

####### 瞬时共享锁和排他锁实现

###### 可重复读（repeatable read）

禁止不可重复读取和脏读取，但是有时可能出现幻读数据。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。Mysql默认使用该隔离级别。这可以通过“共享读锁”和“排他写锁”实现，即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事务结束后再释放。

####### 解决不可重复读

####### 共享锁和排他锁实现

###### 可串行化（serializable）

解决了幻读的问题的。提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

####### 解决幻读

#### 索引以及优化

##### 特点

###### 优点

####### 减少服务器扫描数据量，提高检索速度

######## B+树 + 二分查找代替全表扫描

####### 随机 I / O 变顺序 I / O

######## 范围查询时，减少磁盘寻道

####### 帮助服务器避免排序和临时表

######## 排序和分组时，不需要建临时表

###### 缺点

####### 占物理空间

####### 降低增删改速度

######## 要维护B+树平衡

##### 哈希索引

把键值换算成新的哈希值，根据这个哈希值来定位

###### 无法排序

###### 只支持等值比较，不支持范围查询

###### 只含哈希值和行指针，不存字段值, 需要再去磁盘查找

###### 联合索引 (a, b) 全部列计算哈希值，不能只查询a

###### 速度快，但哈希冲突多时维护代价高

###### InnoBD使用自适应哈希索引

在B+树上给频繁索引值加哈希索引。

##### 索引优化

###### 索引使用场合

####### where

####### order

####### join

####### 覆盖索引

###### 优化

####### 字段要独立存在

```
# 索引失效
select * from user where id+1 = 20; 
```
```
# 索引有效
select * from user where id = 20-1;
```


####### like，不能以通配符%开头

```
 # 索引失效
select * from article where title like '%mysql%';
```
```
 # 索引有效
select * from article where title like 'mysql%';
```

####### or, 需要两边条件都有索引

####### 索引列设置为 NOT NULL ，否则将导致索引失效进行全表扫描

####### 联合索引注意最左匹配原则

####### 不要在索引列上进行计算

####### 注意避免冗余索引

查询 sys 库的 schema_redundant_indexes 表来查看冗余索引

#### 查询优化

##### explain 分析 select 

###### select_type

####### 查询类型，有简单查询、联合查询、子查询等

###### key

####### 使用的索引

###### rows

####### 扫描的行数

###### possible_keys

####### 可选的索引

##### 优化数据访问

###### 只返回必要列：最好不要使用 SELECT *

###### 只返回必要行：使用LIMIT限制 

###### 缓存重复查询的数据

###### 使用索引查询

#### InnoDB 与 MyISAM

##### InnoDB

###### 支持事务

###### 支持外键

###### 主键索引是聚簇索引

####### 索引中保持数据，避免直接读磁盘

###### 支持在线热备份，崩溃后可安全恢复

###### 支持行级锁，，采用MVCC来支持高并发

##### MyISAM

###### 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用

###### 支持BLOB和TEXT的前500个字符索引，支持全文索引

###### 在表有读取查询的同时，支持往表中插入新纪录

#### 范式

##### 规范化

关系模式中存在的问题：
- **数据冗余**：数据重复出现，浪费大量的存储空间
- **更新异常（Update Anomalies）**：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
- **插入异常（Insertion Anomalies）**：如果一个学生函数依赖于系，则无法把一个刚成立、尚无学生的系的信息存入数据库。
- **删除异常（Deletion Anomalies）**：删除一个信息，那么也会丢失其它信息。

规范化理论正是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。

一个低一级范式的关系模式，通过**模式分解（schema decomposition）** 可以转换为若干个高一级范式的关系模式的集合，这种过程就叫**规范化（normalization）**。

满足最低要求的叫第一范式1NF。

###### 第一范式(1NF)

关系模式{Sno序号 Sname学生, Sdept学院, Mname院长, Cname课程, Grade分数}

{Sno, Cname} 为主键

函数依赖：
- Sno -> Sname, Sdept （部分依赖）
- Sdept -> Mname （传递依赖）
- Sno, Cname-> Grade （完全依赖）

####### 属性不可分。

###### 第二范式(2NF) 

根据第二范式分解后：

关系1 {Son, Sname, Sdept, Mname}
- Sno -> Sname, Sdept （完全依赖）
- Sdept -> Mname （传递依赖）

关系2 {Sno, Cname, Grade}
- Sno, Cname -> Grade （完全依赖）

####### 非主属性不部分函数依赖于键码。

###### 第三范式(3NF)

关系1根据第三范式分解：

关系-11{Sno, Sname, Sdept}
- Sno -> Sname, Sdept （完全依赖）

关系-12{Sdept, Mname}
- Sdept -> Mname （完全依赖）


####### 非主属性不传递函数依赖于键码。

### Redis

#### 使用场景

##### String

可以作为数字进行自增自减 
```
set, get, decr, incr, mget 
```

###### 计数器：微博数，粉丝数

###### 缓存热点数据

###### 共享Session

##### Hash

适用于存储对象
```
hget, hset, hgetall 
```

###### 存储用户信息、商品信息等

##### List

双向链表，支持反向查找和变量
```
lpush, rpush, lpop, rpop, lrange
```

###### 微博关注列表，粉丝列表等

###### 消息队列

###### lrange实现分页查询

##### Set

自动重排随机弹出，可实现交集、并集、差集操作
```
sadd, spop, smembers, sunion
```

###### 抽奖

###### 共同关注、共同好友等

##### Sorted Set

元素能够按score进行有序排序
```
zadd, zrange, zrem, zcard
```

###### 排行榜

##### 其他

###### 会话缓存

####### 统一存储多台应用服务器的会话信息

###### 分布式锁实现

####### SETNX命令实现或RedLock分布式锁实现

###### 查找表

####### 如 DNS 记录，与缓存类似，但内容不会失效

#### 与 Memchached 的比较

##### Redis支持5种不同的数据类型，Memcached仅支持String

##### Redis支持数据持久化，Memcached全部数据存于内存中

##### Redis Cluster支持分布式，Memcached只能通过客户端使用一致性哈希实现分布式存储

##### Redis使用单线程、多路IO复用模式，Memcached使用多线程、非阻塞IO模式

#####  

#### 数据淘汰机制

##### 设置过期时间

###### 定期删除

####### 默认每100ms随机抽取一些key并删除过期的

###### 惰性删除

####### 没定期删除的过期key在被查找时会删除

##### 6种淘汰机制

###### volatile-lru

####### 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰

###### volatile-ttl

####### 从已设置过期时间的数据集中挑选将要过期的数据淘汰

###### volatile-random

####### 从已设置过期时间的数据集中任意选择数据淘汰

###### allkeys-lru

####### 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key

###### allkeys-random

####### 从所有数据集中任意选择数据进行淘汰

###### noeviction

####### 禁止驱逐数据

##### Redis 4.0

###### volatile-lfu

####### 从已设置过期时间的数据集中挑选最不经常使用的数据淘汰

LRU（Least Recently Used）：最近最久未使用策略，淘汰上次被访问时间距离现在最久的数据
LFU（Least Frequently Used）：最不经常使用策略，淘汰最近一段时间内使用次数很少的数据


###### allkeys-lfu

####### 当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

## 面向对象

<!--Note-->
### 资料

- 《Head First 设计模式》
<!--/Note-->

### 思想

#### 三大特性

#### 设计原则

### 设计模式

#### 单例模式

手写单例模式，特别是双重检验锁以及静态内部类。

#### 工厂模式

手写工厂模式。


#### MVC

理解 MVC，结合 SpringMVC 回答。

#### 代理模式

结合 Spring 中的 AOP 回答。

#### JDK 中常用的设计模式

例如装饰者模式、适配器模式、迭代器模式等。

## 系统设计

<!--Note-->
#### 资料

- 《大型网站技术架构》
- 《从 Paxos 到 Zookeeper》
- 《微服务设计》
<!--/Note-->

### 基础

- [系统设计基础](https://cyc2018.github.io/CS-Notes/#/notes/系统设计基础)

#### 性能

#### 伸缩性

#### 扩展性

#### 可用性

#### 安全性

### 分布式

- [分布式](https://cyc2018.github.io/CS-Notes/#/notes/分布式)

#### 分布式事务

#### CAP

#### BASE

#### Paxos

#### Raft

#### 分布式锁

#### 分布式 ID

### 集群

- [集群](https://cyc2018.github.io/CS-Notes/#/notes/集群)

#### 负载均衡

#### Session 管理

### 缓存

- [缓存](https://cyc2018.github.io/CS-Notes/#/notes/缓存)

#### 缓存特征

#### LRU

#### 缓存位置

#### CDN

#### 缓存问题

#### 一致性哈希

### 攻击技术

- [攻击技术](https://cyc2018.github.io/CS-Notes/#/notes/攻击技术)

#### XSS

#### CSRF

#### SQL 注入

#### DDoS

### 消息队列

- [消息队列](https://cyc2018.github.io/CS-Notes/#/notes/消息队列)

#### 消息模型

#### 使用场景

#### 可靠性

### 高并发系统

#### 秒杀系统

#### 限流算法

#### 服务熔断与服务降级

### 服务拆分

#### 幂等性

#### 远程服务访问方法

#### 微服务

#### SOA

### 系统设计

#### Web 页面请求过程

#### 二维码登录

#### TinyURL

#### KV 存储系统

#### 搜索引擎

## Java

<!--Note-->
### 资料

- 《JAVA 核心技术》
- 《Java 编程思想》
- 《Effective java 中文版》
- 《深入理解 Java 虚拟机》
- 《Java 并发编程实战》
- 《精通 Spring 4.x》
- 《Spring 揭秘》
<!--/Note-->

### 基础

- [Java 基础](https://cyc2018.github.io/CS-Notes/#/notes/Java%20基础)

#### 数据类型

##### 基本数据类型

###### byte

####### 8bit，1字节

###### char

####### 16bit，2字节

###### short

####### 16bit，2字节

###### int

####### 32bit，4字节

###### float

####### 32bit，4字节

###### long

####### 64bit，8字节

###### double

####### 64bit，8字节

###### boolean

####### 用int代替，boolean数组用byte数组代替

#### Java 特性

##### 面向对象和面向过程

###### 面向过程

####### 性能更高

######## 因为类调用时需要实例化，开销比较大，比较消耗资源

######## 因此单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发（C语言）

###### 面向对象

####### 易维护、易复用、易扩展

######## 由于封装、继承、多态的特性

##### JVM、JDK 和 JRE

###### JVM

####### JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。

###### JDK

####### 用于支持 Java 程序开发的最小环境

####### Java 语言 + Java 虚拟机 + Java API 类库

###### JRE

####### 支持 Java 程序运行的标准环境

####### Java 虚拟机 + Java API 类库中的 Java SE API 子集

##### Java 和 C++

###### Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 即支持面向对象也支持面向过程。

###### Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。

###### Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。

###### Java 支持自动垃圾回收，而 C++ 需要手动回收。

###### Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。

###### Java 不支持操作符重载，而 C++ 支持操作符重载。

###### Java 语言中没有结束符，C++字符串或字符数组最后都会 用‘\0’来表示结束。

##### Java 8 新特性 

###### 接口的默认方法

```
interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
```

###### Lambda 表达式

```
List<String> names = Arrays.asList("peter", "anna", "mike", "xenia");

Collections.sort(names, new Comparator<String>() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});
```

```
Collections.sort(names, (a, b) -> b.compareTo(a));
```

####### 允许把方法作为参数，但必须是函数式接口的方法

###### 函数式接口


```
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
Converter<String, Integer> converter = (from) -> Integer.valueOf(from);
Integer converted = converter.convert("123");
System.out.println(converted);    // 123
```

####### 是指 只有一个抽象方法 的接口，每个该类型的lambda表达式都会被匹配到这个抽象方法。

###### 方法与构造函数引用

####### 通过 className :: funName / new 来指定一个方法 / 构造器，一般和 Lambda 联用

###### Date Time API 

####### LocalDate/LocalTime 和 LocalDateTime

####### Timezones 时区

###### Stream API

###### Optional 类 

####### 是一个可以为null的容器对象，用来解决空指针异常

#### 继承

##### 重载和重写

###### 重写

####### 子类对父类的允许访问的方法的实现过程进行重新编写,发生在子类中，方法名、参数列表必须相同

####### 限制

######## 访问权限 >= 父类

######## 返回类型 <= 父类

即为父类方法返回类型或其子类型

######## 异常类型 <= 父类

###### 重载

####### 发生在同一个类中，方法名必须相同，参数类型、个数、顺序至少有一个不同。

##### 接口和抽象类

###### 比较

####### 一个类可以实现多个接口，但是不能继承多个抽象类。

####### 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。

####### 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限

###### 使用选择

####### 使用接口

######## 需要让不相关的类都实现一个方法

######## 需要使用多重继承

####### 使用抽象类

######## 需要在几个相关的类中共享代码

######## 需要能控制继承来的成员的访问权限，而不是都为 public。

######## 需要继承非静态和非常量字段。

#### String, StringBuffer and StringBuilder

##### 可变性

###### String 不可变

```
// Java 8
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    // 使用final关键字修饰
    private final char value[];
}
```

```
// Java 9
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}
```

####### 可缓存 hash 值

####### String Pool 的需要

####### 线程安全

###### StringBuffer 和 StringBuilder 可变

####### StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类

```
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    /**
     * The value is used for character storage.
     */
    // 没有用 final 关键字修饰
    char[] value;

    /**
     * The count is the number of characters used.
     */
    int count;

    AbstractStringBuilder(int capacity) {
        value = new char[capacity];
    }
```

##### 线程安全

###### String 不可变，因此是线程安全的

###### StringBuilder 不是线程安全的

###### StringBuffer 内部用 synchronized 同步，是线程安全的

##### 性能

###### 每次对 String 进行操作都还生成新对象，对 StringBuilder 和 StringBuffer 进行操作则不会

######  StringBuilder 不需要同步，性能比 StringBuffer 高

#### Object 通用方法

```

public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class<?> getClass()

protected void finalize() throws Throwable {}

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException

```

##### equals()

###### equals() 和 ==

####### == 判断两个对象的地址是否相等，而 equals() 判断两个对象是否等价

##### hashCode()

###### hashCode() 的作用就是获取哈希码，哈希码的作用是确定该对象在哈希表中的索引位置。

###### 等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价

###### 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。

#### 异常

##### Throwable

###### 图

#######  

#### 反射

##### 基本运用

###### 获取 Class 对象

####### Class 类的静态 forName()

```

Class<?> klass = Class.forName("com.mysql.jdbc.Driver");
```

####### T.class

```

Class<?> klass1 = int.class;
Class<?> klass2 = Double[].class;
```

####### Object 类的 getClass()

```

StringBuilder str = new StringBuilder("123");
Class<?> klass = str.getClass();
```

###### java.lang.reflect

####### Field 类

######## 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段

```

Class<?> c = Student.class;
Field f = c.getField("name");
Constructor constructor = c.getConstructor(String.class);
Object obj = constructor.newInstance();
//为Student对象中的name属性赋值
f.set(obj, "zhangsan");
```

####### Method 类

######## 可以使用 invoke() 方法调用与 Method 对象关联的方法

```

Class<?> klass = MethodClass.class;
Object obj = klass.newInstance();

//获取methodClass类的add方法
Method method = klass.getMethod("add",int.class,int.class);
//调用method对应的方法 => add(1,4)
Object result = method.invoke(obj,1,4);
```


####### Constructor 类

######## 可以用 Constructor 的 newInstance() 创建新的对象

```

Class<?> c = String.class;
//获取String类带一个String参数的构造器
Constructor constructor = c.getConstructor(String.class);
//根据构造器创建实例
Object obj = constructor.newInstance("23333");
```

##### 优点

###### 可扩展性

####### 应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。

###### 可视化开发环境

####### 可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码

###### 调试器和测试工具

####### 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义

##### 缺点

###### 性能开销

####### 反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化

###### 安全限制

####### 使用反射技术要求程序必须在一个没有安全限制的环境中运行

###### 内部暴露  

####### 反射允访问私有的属性和方法, 可能导致代码功能失调并破坏可移植性

### 虚拟机

- [Java 虚拟机](https://cyc2018.github.io/CS-Notes/#/notes/Java%20虚拟机)

#### 程序计数器

##### 当前线程所执行的字节码的行号指示器

##### 对于Java方法，记录正在执行的虚拟机字节码指令的地址；对于Native方法，则为空

#### 虚拟机栈

##### 栈帧用于存储

###### 局部变量表

####### 存放编译期可知的基本数据类型、对象引用、returnAddress类型。

###### 操作数栈

###### 动态链接

###### 方法出口

#### 方法区

##### 存储已被JVM加载的

###### 类信息

###### 常量

###### 静态变量

###### 即时编译器编译后的代码

#### Java对象创建

##### 类加载检查

###### new -> 常量池中是否有该类的符号引用 -> 是否已类加载

##### 分配内存

###### 分配方式

####### 指针碰撞

######## 用过和没用过的内存各放一端，中间用分界值指针隔开

######## 场合：没内存碎片

######## GC收集器：Serial、ParNew

####### 空闲列表

######## 维护列表来记录空闲内存

######## 场合：大量内存碎片

######## GC收集器：CMS

##### 初始化零值

###### 虚拟机将分配到的内存空间都初始化为零值

##### 设置对象头

###### 虚拟机设置对象的哈希码、GC 分代年龄、锁状态标志等信息

##### 执行init方法

###### 虚拟机执行 <init> 方法进行初始化

#### 可做GC Roots的对象

除堆外被其他数据区引用的对象都可做GC Roots


##### 虚拟机栈中引用的对象

##### 方法区中类静态属性引用的对象

##### 方法区中常量引用的对象

##### 本地方法栈中JNI（Native方法）引用的对象

##### 被同步锁持有的对象

##### Java虚拟机内部的引用 

##### JMXBean、 JVMTI中注册的回调、 本地代码缓存

#### 引用

##### 强引用

###### Object obj = new Object()

###### 引用在，不回收

##### 软引用 (SoftReference) 

###### 将OOM前，把这些对象回收，若仍OOM，才抛出异常

###### 可以加快回收速度，维护系统的运行安全，防止内存溢出等问题的产生

##### 弱引用 (WeakReference)

###### 下一次GC则清除

##### 虚引用 (PhantomReference)

###### 仅为了回收时收到系统通知, 跟踪对象被垃圾回收的活动

#### 回收方法区

##### 回收内容

###### 废弃常量

####### 常量池中不再引用的字面量、符号引用

###### 不再使用的类

####### 该类的所有实例已被回收

####### 该类的类加载器已被回收

####### 对应的java.lang.Class对象没被反射引用

#### 垃圾收集器

#####  

###### Serial + Serial Old : 单线程、客户端

###### ParNew + CMS : 多线程、服务端、停顿时间短

###### Parallel Scavenge + Parallel Old ：多线程、高吞吐量

#### CMS收集器

##### 基于标记-清除算法

初始标记、重新标记需要停顿，并发标记、并发清除与用户程序同时并发

###### 初始标记

####### 只标记GC Roots直接关联的对象

###### 并发标记

####### 从GC Roots直接关联对象开始遍历整个对象图

###### 重新标记

####### 修正并发标记期间，因用户程序运作导致的标记变动

###### 并发清除

####### 清掉标记阶段判断的已死亡对象

##### 三个缺点

###### 对CPU资源敏感

####### 并发阶段虽不会停顿，但会占用部分线程使吞吐率降低

###### 无法处理浮动垃圾

####### 浮动垃圾：GC并发阶段产生的垃圾，只能下次GC时清除

####### 因此CMS收集器需要预留足够空间供用户线程使用

####### 预留内存不足时会出现Concurrent Mode Failure，需启动Serial Old收集器重新GC

###### 产生大量空间碎片

####### 往往出现老年代有很多剩余空间却找不到足够大的连续空间，不得不提前触发Full GC

#### Garbage First收集器（JDK 9）

##### 特点

###### 可预测停顿时间模型 

####### 能指定M毫秒的时间片段内，GC时间不超过N毫秒

###### 分Region的内存布局

####### 每个Region可扮演新生代的Eden、Survivor或老年代空间

####### 单次回收的最小单元

######## 每次GC都是Region大小的整数倍

###### 优先级区域回收方式

####### 维护一个优先级列表，根据设定的允许停顿时间，优先回收价值最大的Region

价值：回收所获得的空间大小以及回收所需时间的经验值

##### 基于标记-整理和标记-复制 

除并发标记外，其余阶段要停顿

###### 初始标记

####### 标记GC Roots的直接关联对象，并修改TAMS指针的值

###### 并发标记

####### 对堆中对象进行可达性分析

###### 最终标记

####### 修正用户程序导致的标志变动，即处理并发标记阶段遗留的少量SATB记录

###### 筛选回收

####### 对每个Region的价值和成本排序，根据用户期望停顿时间制定回收计划

####### 决定回收Region将存活对象复制到空Region中，然后清除

##### 与CMS收集器对比

###### 优点

####### 可指定最大停顿时间、分Region的内存布局、按收益动态确定回收集等

####### 不产生内存空间碎片

###### 缺点

####### 内存占用高

######## G1卡表复杂且每个Region一个，CMS卡表简单且只有一份

- 记忆集记录chong非 GC 区域指向 GC 区域的指针。
- 卡表是指以“卡精度”实现的记忆集。
- 卡表是一个字节数组，每个元素代表一个区域，将存在跨代指针的区域标识为1，称元素变脏。


####### 额外负载高

######## G1要写前屏障和后屏障，CMS只写前屏障

- 通过写屏障技术维护卡表状态的。
- 写屏障是在虚拟机层面对“引用类型字段赋值”的AOP切面， 在引用对象赋值时产生一个环形（Around） 通知。
- 在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier） ， 在赋值后的则叫作写后屏障（Post-Write Barrier） 。

###### 小内存应用用CMS，大内存应用用G1

内存分界为6～8GB之间。

#### 加载

“加载”是“类加载”过程的一个阶段，不要混淆。

##### 三个动作

###### 通过类的完全限定名称获取定义该类的二进制字节流

###### 将该字节流表示的静态存储结构转换为方法区的运行时存储结构

###### 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口

#### 类的初始化时机

##### 主动引用

触发类初始化

###### 遇到new、getstatic、putstatic 或 invokestatic 字节码指令

####### new实例化对象

####### 设置或读取类的静态字段

######## 被final修饰、已在编译期把结果放入常量池的静态字段除外。

####### 调用类的静态方法

###### 对类进行反射调用 

###### 初始化时先初始化父类

接口仅在真正用到父接口时才初始化。

###### 虚拟机启动时，会先初始化要执行的主类（包含main()方法的类）

###### 实现了有默认方法的接口，先初始化该接口

###### 使用JDK 7的动态语言支持时

如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、 REF_putStatic、 REF_invokeStatic、 REF_newInvokeSpecial四种类型的方法句柄， 并且这个方法句柄对应的类没有进行过初始化， 则需要先触发其初始化。

##### 被动引用

不触发类初始化

###### 通过子类引用父类的静态字段，子类不初始化

```
System.out.println(SubClass.value); // value字段在SuperClass中定义
```

###### 通过数组定义来引用类，此类不初始化

```
SuperClass[] sca = new SuperClass[10];
```

###### 调用类中常量时不触发初始化

常量会在编译阶段就存入调用类的常量池中。
```
System.out.println(ConstClass.HELLOWORLD);
```

### 并发

- [Java 并发](https://cyc2018.github.io/CS-Notes/#/notes/Java%20并发)

#### 死锁

##### 避免死锁

###### 破坏互斥条件

###### 破坏请求与保持条件

####### 一次性申请所有资源

###### 破坏不剥夺条件

####### 申请不到，主动释放已占有资源

###### 破坏循环等待条件

####### 顺序申请资源，反序释放

##### 手写死锁

```
public class DeadLock {
    private static final Object resource1 = new Object();
    private static final Object resource2 = new Object();

    public static void main (String[] args) {
        new Thread(() -> {
            synchronized(resource1) {
            	// Thread.sleep(1000);
            	synchronized(resource2) {
            		System.out.println("get resource2");
            	}
            }
        }).start();
        new Thread(() -> {
            synchronized(resource2) {
            	// Thread.sleep(1000);
            	synchronized(resource1) {
            		System.out.println("get resource1");
            	}
            }
        }).start();
    }
}
```

#### 生产者-消费者与队列

##### 使用synchronized实现生产者消费者问题

```java
public  class ProducerConsumer {
    private static final int MAX_SIZE = 10;
    private final LinkedList<Object> list = new LinkedList<>();

    public void produce() {
        synchronized (list) {
            while (list.size() == MAX_SIZE) {
                list.wait();
            }
            list.add(new Object());
            list.notifyAll();
        }
    }

    public void consume() {
        synchronized (list) {
            while (list.size() == 0) {
                list.wait();
            }
            list.remove();
            list.notifyAll();
        }
    }
    
    public static void main(Stirng[] args) {
    	ProducerConsumer product = new ProducerConsumer();
        
        Thread producer = new Thread(() -> {
        	while(true) {
                product.produce();
                // Thread.sleep(1000);
            }
        });
        Thread consumer = new Thread(() -> {
        	while(true) {
                product.consume();
                // Thread.sleep(1000);
            }
        });
        
        producer.start();
        consumer.start();
    }
}
```

##### 使用信号量解决生产者-消费者问题

生产值-消费者（有界缓冲区）问题：两个进程共享一个固定大小的缓冲区。
生产者将信息放入缓冲区，消费者从缓冲区取出信息。缓冲区属于临界资源。

```
private LinkedList<Object> list = new LinkedList<Object>();
private static final int N = 10;
// 互斥量
private final Semaphore mutex = new Semaphore(1);
// 空位
private final Semaphore empty = new Semaphore(N);
// 满位
private final Semaphore full = new Semaphore(0);

public void producer() {
    while(true) {
    	empty.acquire();
        mutex.acquire();
        list.add(new Object());
        mutex.release();
        full.release();
        
        // Thread.sleep(1000);
    }
}

public void consumer() {
    while(true) {
    	full.acquire();
        mutex.acquire();
        list.remove();
        mutex.release();
        empty.release();
        
        // Thread.sleep(1000);
    }
}
```

##### 使用 BlockingQueue 实现生产者消费者问题

```
public class ProducerConsumer {

    private static BlockingQueue<String> queue = 
    	new ArrayBlockingQueue<>(5);

    private static class Producer extends Thread {
        @Override
        public void run() {
            try {
                queue.put("product");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print("produce..");
        }
    }

    private static class Consumer extends Thread {

        @Override
        public void run() {
            try {
                String product = queue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.print("consume..");
        }
    }
}
```

#### 线程生命周期

#####  

#####  

#### 先行发生原则

“→”表示先行发生于

##### 程序次序规则

###### 一个线程内，写在前面的操作 → 写在后面的操作

##### 管程锁定规则

###### 同一锁，unlock操作 → lock操作

##### volatile变量规则

###### 对volatile变量，写操作 → 读操作

##### 线程启动规则

###### Thread.start() → 线程的所有操作 

##### 线程中断规则

###### Thread.interrupt() → Thread.interrupted()

##### 线程终止规则

###### 线程的所有操作 →  终止检测Thread.join()、Thread.isAlive()

##### 对象终结规则

###### 一个对象，初始化完成 → finalize()开始

##### 传递性

###### A操作 → B操作，B操作 → C操作，则A操作 → C操作

#### synchronized

保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

##### 与Reentrantlock的区别

###### 两者都是可重入锁

###### synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

###### ReentrantLock高级功能

####### 等待可中断

####### 公平锁

####### 可绑定多个Condition对象，选择性通知

###### 性能上已差异不大，优先选synchronized

#### 线程池

##### 好处

###### 降低资源消耗

####### 无需重复创建消耗线程

###### 提高响应速度

####### 无需等待线程创建

###### 提高线程可管理性

####### 线程池统一分配、调优和监控

###### 提供更多强大的功能

####### 线程池具备可扩展性

##### ThreadPoolExecutor

```
public class ThreadPoolExecutorDemo {
    private static final int CORE_POOL_SIZE = 5;
    private static final int MAX_POOL_SIZE = 10;
    private static final int QUEUE_CAPACITY = 20;
    private static final Long KEEP_ALIVE_TIME = 1L;

    public static void main(String[] args) {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                CORE_POOL_SIZE,
                MAX_POOL_SIZE,
                KEEP_ALIVE_TIME,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(QUEUE_CAPACITY),
                new ThreadPoolExecutor.CallerRunsPolicy()
        );

        for (int i = 0; i < 10; i++) {
            executor.execute(() ->
                System.out.println(Thread.currentThread()));
            
            Future<String> future = executor.submit(() ->
                    Thread.currentThread().getName());

            try {
                System.out.println(future.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }

        executor.shutdown();
    }
}

```

###### 构造函数参数

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
    throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

####### corePoolSize

######## 最小可同时运行的线程数

####### maximumPoolSize

######## 队列容量满时，同时运行的线程数变最大线程数

####### workQueue

######## 当前运行线程数到达核心线程数时，新任务存入队列

####### keepAliveTime

######## 池中线程数大于corePoolSize且无新任务提交，核心线程外线程等待keepAliveTime后销毁

####### unit

######## keepAliveTime的时间单位

####### ThreadFactory

######## 线程工厂，用来创建线程，一般默认即可

####### handler

######## 饱和策略

###### 饱和策略

当前同时运行的线程数达到最大线程数且队列也已满时，所需的策略

####### ThreadPoolExecutor.AbortPolicy

######## 抛出 RejectedExecutionException来拒绝新任务的处理。

####### ThreadPoolExecutor.CallerRunsPolicy

######## 调用执行自己的线程运行任务。

####### ThreadPoolExecutor.DiscardPolicy

######## 不处理新任务，直接丢弃掉。

####### ThreadPoolExecutor.DiscardOldestPolicy

######## 丢弃最早的未处理的任务请求。

#### Atomic原子类

##### 基本类型

##### 数组类型

##### 引用类型

基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用 引用类型原子类。

##### 对象的属性修改类型

```
import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;

public class AtomicIntegerFieldUpdaterTest {
    public static void main(String[] args) {
        AtomicIntegerFieldUpdater<User> a = 
        	AtomicIntegerFieldUpdater.newUpdater(User.class, "age");

        User user = new User("Java", 22);
        System.out.println(a.getAndIncrement(user)); // 22
        System.out.println(a.get(user)); // 23
    }
}
```

### 容器

- [Java 容器](https://cyc2018.github.io/CS-Notes/#/notes/Java%20容器)

#### ArrayList

##### 与LinkedList的区别

###### 底层数据结构

####### ArrayList为动态数组，LinkedList为双向链表

###### 操作复杂度

####### 对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。

####### 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。

###### ArrayList支持快速随机访问，LinkedList不支持

####### ArrayList优先选择for循环遍历，LinkedList优先选择foreach遍历

###### 空间浪费

####### ArrayList需要在数组尾部预留一定空间

####### LinkedList每个元素消耗更多的空间

##### 与Vector的区别

###### Vector的所有方法都是同步的，开销更大

###### Vector 每次扩容大小为 2 倍，而 ArrayList 是 1.5 倍。

#### HashMap

##### 存储结构

###### JDK 1.7

####### Entry数组+链表（拉链法）

###### JDK 1.8

####### 数组+链表+红黑树

######## 数组长度>=64，链表长度>=8时，转红黑树

##### 扩容

###### resize()

####### JDK 1.7

```
void resize(int newCapacity) {
    Entry[] oldTable = table;
    int oldCapacity = oldTable.length;
    if (oldCapacity == MAXIMUM_CAPACITY) {
        threshold = Integer.MAX_VALUE;
        return;
    }
    Entry[] newTable = new Entry[newCapacity];
    transfer(newTable);
    table = newTable;
    threshold = (int)(newCapacity * loadFactor);
}

```

######## 原方法计算位置：hashCode() -> hash() -> (n - 1) & hash

```
// oldTable的所有键值对转移到newTable
void transfer(Entry[] newTable) {
    Entry[] src = table;
    int newCapacity = newTable.length;
    // 遍历所有元素
    for (int j = 0; j < src.length; j++) {
        Entry<K,V> e = src[j];
        if (e != null) {
            src[j] = null;
            do {
                Entry<K,V> next = e.next;
                // ReHash：重新计算hash
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null);
        }
    }
}
```

####### JDK 1.8

```
final Node<K,V>[] resize() {
    Node<K,V>[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap > 0) {
        // 超过最大值就不再扩充了，就只好随你碰撞去吧
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 没超过最大值，就扩充为原来的2倍
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold
    }
    else if (oldThr > 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else { 
        // signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // 计算新的resize上限
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
        Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // 把每个bucket都移动到新的buckets中
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { 
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                        // 原位置不变
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        // 原位置 + oldCap
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // 原位置放到bucket里
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    // 原位置 + oldCap放到bucket里
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}

```

######## 扩容后位置 = 原位置 or 原位置 + 旧容量

```
// newCap = oldCap << 1
oldCap              : 00010000
newCap              : 00100000

// hash & oldCap == 0
// hash % oldCap == hash % oldCap
hash(key1)          : 00100011
hash(key1) % oldCap : 00000011
hash(key1) % newCap : 00000011

// hash & oldCap != 0
// hash % newCap == hash % oldCap + oldCap
hash(key2)          : 00110011
hash(key2) % oldCap : 00000011
hash(key2) % newCap : 00010011
```


##### 计算桶下标

```
// i = hash(key) % n, n为数组长度
int hash = hash(key);
int i = (n - 1) & hash;
```

###### 扰动函数hash方法

####### JDK1.7

```
final int hash(Object k) {
    int h = hashSeed;
    if (0 != h && k instanceof String) {
        return sun.misc.Hashing.stringHash32((String) k);
    }
	// 1次异或运算
    h ^= k.hashCode();

    // 2次位运算 + 2次异或运算 
    h ^= (h >>> 20) ^ (h >>> 12);
    
    // 2次位运算 + 2次异或运算
    return h ^ (h >>> 7) ^ (h >>> 4);
}
```

######## 9次扰动

####### JDK1.8

```
// JDK 1.8
static final int hash(Object key) {
    int h;
    // 1次位运算 + 1次异或运算
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

######## 2次扰动，性能更好

##### put方法

###### JDK1.7

```
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    // 键为 null 时，存放在第0个桶
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    // 确定桶下标
    int i = indexFor(hash, table.length);
    // 遍历对比 key，有相同则直接覆盖
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }

    modCount++;
    // 插入新键值对
    addEntry(hash, key, value, i);
    return null;
}
```

####### 先判断扩容，再插入键值对

```
void addEntry(int hash, K key, V value, int bucketIndex) {
	// 元素个数 >= 阈值，且插入下标的桶不为空，则扩容
    if ((size >= threshold) && (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}
```

####### 新键值对采用头插法插入

```
void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex];
    // 头插法，链表头部指向新的键值对
    table[bucketIndex] = new Entry<>(hash, key, value, e);
    size++;
}
```

###### JDK1.8

```
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    // table未初始化或者长度为0，进行扩容
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
        
    // 计算桶下标，桶中无元素则直接插入
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
        
    // 桶中已经存在元素
    else {
        Node<K,V> e; K k;
        // 比较桶中第一个元素的key值
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
        // 若为树结点
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        // 为链表结点
        else {
        	// 遍历链表
            for (int binCount = 0; ; ++binCount) {
                // 到达链表尾部,采用尾插法插入
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // 达到阈值转红黑树
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                // 判断key是否相等，相等则跳出
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;

                p = e;
            }
        }
        // 表示在桶中找到相等key值，更新值
        if (e != null) { 
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    // 最后判断是否扩容
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
} 

```

####### 新键值对采用尾插法插入

######## 不容易出现循环链表

####### 先插入键值对，最后统一判断扩容

####### 

########  

##### 与Hashtable比较

###### Hashtable 使用 synchronized 同步，开销更大，HashMap 是非线程安全的

###### HashMap 可以插入键为 null，HashTable 会抛 NullPointerException

###### Hashtable初始容量为11，扩容为2n+1, HashMap初始容量为16，扩容为2n

###### JDK 1.8后HashMap会转红黑树，Hashtable不会

###### HashMap 的迭代器是 fail-fast 迭代器

###### HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的

#### LinkedHashMap

##### LRU 缓存

```

class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final int MAX_ENTRIES = 3;
	
    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
    
    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > MAX_ENTRIES;
    }
}
```

###### 设定MAX_ENTRIES

###### accessOrder设为true

###### 覆盖removeEldestEntry()方法返回true

### I/O

- [Java IO](https://cyc2018.github.io/CS-Notes/#/notes/Java%20IO)

### Web

- [69 道 Spring 面试题和答案](http://ifeve.com/spring-interview-questions-and-answers/)
- [Spring 面试题](https://github.com/Homiss/Java-interview-questions/blob/master/%E6%A1%86%E6%9E%B6/Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98.md)
- [Spring 面试问答 Top 25](http://www.importnew.com/15851.html)
- [Spring 总结以及在面试中的一些问题.](https://www.cnblogs.com/wang-meng/p/5701982.html)


#### SpringMVC

##### 工作原理  

```
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
	
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
	ModelAndView mv = null;

	mappedHandler = getHandler(processedRequest);

	HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

	if (!mappedHandler.applyPreHandle(processedRequest, response)) {
		return;
	}

	mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
    
	mappedHandler.applyPostHandle(processedRequest, response, mv);
	
    Locale locale = this.localeResolver.resolveLocale(request);
    response.setLocale(locale);

    View view;
 
	// 若 mv 中的 view 是 String 类型，即处理器返回的是模板名称，将其解析为具体的 View 对象
    if (mv.isReference()) {
        view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);
    }
    else {
        view = mv.getView();
    }

	view.render(mv.getModelInternal(), request, response);

}
```

###### Servlet 容器接收浏览器发来的请求，并将请求委托给 DispatcherServlet 处理

###### DispatcherServlet 将 HttpServletRequest 传给 HandlerMapping， 返回包含拦截器和 Handler 的 HandelExecutionChain

###### 对处理器进行适配，获取可执行处理器方法的适配器 HandlerAdapter

###### 执行拦截器 preHandle 方法

###### 通过 HandlerAdapter 调用处理器方法，返回 ModelAndView

###### 执行拦截器 PostHandle 方法

###### 将视图名解析成物理视图名(具体的页面地址)，再生成并返回视图对象

###### 对 View 进行渲染, 然后执行拦截器 afterCompletion 方法，最后将渲染结果返回给用户

#### Bean的作用域(scope)

##### singleton

###### 单例模式，默认值

##### prototype

###### 每次调用getBean()，返回一个新实例

##### request

###### 每个HTTP请求都创建一个新Bean，仅在当前HTTP request 内有效

##### session

###### 每个HTTP Session对应一个新Bean，仅在当前 HTTP session 内有效

##### globalSession

###### 全局session作用域，仅用于portlet的web应用中

#### Bean加载方式

##### 基于XML的Bean定义

##### 基于注解的Bean定义

###### Bean扫描注解

####### @Component

######## 通用bean注解

####### @Repository

######## 对应持久层（Dao）层

####### @Service

######## 对应服务层

####### @Controller

######## 对应Spring MVC 控制层

##### 基于Java代码装载Bean

#### Bean生命周期

#####  

######  

######  

#### Spring IOC

##### 控制反转（IoC）

###### 一种面向对象编程的设计思想

###### 借助“第三方”实现对象之间依赖关系的解耦

##### 依赖注入（DI）

###### 实现控制反转的一种设计模式，将一个对象作为参数传入到另一个对象中去。

##### IoC容器，是实现依赖注入的关键，本质上是一个工厂

## C++

## 中间件

### RabbitMQ

### ZooKeeper

### Dubbo

### Nginx

## 其它知识

### 新技术

### 开源项目

## 项目

## 面试相关

### 简历

### 投递
